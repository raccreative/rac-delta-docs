"use strict";(globalThis.webpackChunkrac_delta_docs=globalThis.webpackChunkrac_delta_docs||[]).push([[3006],{3589:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"core/services","title":"Services","description":"In order to organize and to use rac-delta properly, it is important to atomize responsibilities of the protocol in different services.","source":"@site/docs/core/services.md","sourceDirName":"core","slug":"/core/services","permalink":"/rac-delta-docs/core/services","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"Storage Adapter","permalink":"/rac-delta-docs/core/storage-adapter"},"next":{"title":"Pipelines","permalink":"/rac-delta-docs/core/pipelines"}}');var s=r(4848),t=r(8453);const o={sidebar_position:5},c="Services",a={},l=[{value:"Hasher service",id:"hasher-service",level:2},{value:"Validation service",id:"validation-service",level:2},{value:"Delta service",id:"delta-service",level:2},{value:"AsyncChunkStream",id:"asyncchunkstream",level:3},{value:"Reconstruction service",id:"reconstruction-service",level:2},{value:"ChunkSource",id:"chunksource",level:3},{value:"ReconstructionOptions",id:"reconstructionoptions",level:3},{value:"<code>forceRebuild</code>",id:"forcerebuild",level:4},{value:"<code>verifyAfterRebuild</code>",id:"verifyafterrebuild",level:4},{value:"<code>inPlaceReconstructionThreshold</code>",id:"inplacereconstructionthreshold",level:4},{value:"<code>fileConcurrency</code>",id:"fileconcurrency",level:4},{value:"<code>onProgress</code>",id:"onprogress",level:4}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",p:"p",pre:"pre",strong:"strong",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"services",children:"Services"})}),"\n",(0,s.jsx)(n.p,{children:"In order to organize and to use rac-delta properly, it is important to atomize responsibilities of the protocol in different services."}),"\n",(0,s.jsx)(n.p,{children:"rac-delta core is composed by four main services that will connect every operation of the protocol together."}),"\n",(0,s.jsx)(n.h2,{id:"hasher-service",children:"Hasher service"}),"\n",(0,s.jsxs)(n.p,{children:["This service will be responsible of implementing hashing to create file and chunk hashes, to verify integrity and to generate ",(0,s.jsx)(n.code,{children:"FileEntry"})," and ",(0,s.jsx)(n.code,{children:"Chunk"})," objects with its hashes."]}),"\n",(0,s.jsx)(n.p,{children:"Here it is the abstraction of the service, ready to be implemented with any library you prefer."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="Abstract hasher service in TypeScript"',children:"interface StreamingHasher {\n  update(data: Uint8Array | Buffer): void;\n  digest(encoding?: 'hex'): string;\n}\n\ninterface HasherService {\n  hashFile(filePath: string, rootDir: string, chunkSize: number): Promise<FileEntry>;\n\n  hashStream(stream: AsyncChunkStream, onChunk?: (chunk: Uint8Array) => void): Promise<Chunk[]>;\n\n  hashBuffer(data: Uint8Array): Promise<string>;\n\n  verifyChunk(data: Uint8Array, expectedHash: string): Promise<boolean>;\n\n  verifyFile(path: string, expectedHash: string): Promise<boolean>;\n\n  createStreamingHasher(): Promise<StreamingHasher>;\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"validation-service",children:"Validation service"}),"\n",(0,s.jsxs)(n.p,{children:["The validation service is used only for validation of files and rd-index.json files. It uses the ",(0,s.jsx)(n.code,{children:"hasher service"})," for this, has basic methods that returns boolean."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="Abstract validation service in TypeScript"',children:"interface ValidationService {\n  validateFile(entry: FileEntry, path: string): Promise<boolean>;\n\n  validateIndex(index: RDIndex, basePath: string): Promise<boolean>;\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"delta-service",children:"Delta service"}),"\n",(0,s.jsx)(n.p,{children:"The delta service is responsible of mainly creating rd-indexes, comparing rd-indexes or merging rd-indexes."}),"\n",(0,s.jsxs)(n.p,{children:["Comparing two rd-index files will generate a ",(0,s.jsx)(n.a,{href:"/core/interfaces#deltaplan",children:"Delta Plan"})," that will include the changes to upload or download."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="Abstract delta service in TypeScript"',children:"interface DeltaService {\n  createIndexFromDirectory(\n    rootPath: string,\n    chunkSize: number,\n    concurrency?: number,\n    ignorePatterns?: string[]\n  ): Promise<RDIndex>;\n\n  createFileEntryFromStream(stream: AsyncChunkStream, path: string): Promise<FileEntry>;\n\n  compare(source: RDIndex, target: RDIndex | null): DeltaPlan;\n\n  mergePlans(base: DeltaPlan, updates: DeltaPlan): DeltaPlan;\n\n  compareForUpload(localIndex: RDIndex, remoteIndex: RDIndex | null): Promise<DeltaPlan>;\n\n  compareForDownload(localIndex: RDIndex | null, remoteIndex: RDIndex): Promise<DeltaPlan>;\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"asyncchunkstream",children:"AsyncChunkStream"}),"\n",(0,s.jsxs)(n.p,{children:["As you can see above, ",(0,s.jsx)(n.code,{children:"createFileEntryFromStream"})," uses ",(0,s.jsx)(n.code,{children:"AsyncChunkStream"}),", an object that extends AsyncIterable for a more custom experience:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"interface AsyncChunkStream extends AsyncIterable<Uint8Array> {\n  nextChunk(): Promise<Uint8Array | null>;\n  reset?(): Promise<void>;\n  close?(): Promise<void>;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"As how streams are treated differently in each language, take this only as recommendation and a guide, it can differ on other languages like Python or Rust."}),"\n",(0,s.jsx)(n.h2,{id:"reconstruction-service",children:"Reconstruction service"}),"\n",(0,s.jsx)(n.p,{children:"The reconstruction service is a complex service that is responsible of reconstruct files via chunks."}),"\n",(0,s.jsx)(n.p,{children:"It can reconstruct a single file or all files of a given delta plan."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="Example reconstruction service abstraction in TypeScript"',children:"interface ReconstructionService {\n  reconstructFile(\n    entry: FileEntry,\n    outputPath: string,\n    chunkSource: ChunkSource,\n    options?: ReconstructionOptions\n  ): Promise<void>;\n\n  reconstructAll(\n    plan: DeltaPlan,\n    outputDir: string,\n    chunkSource: ChunkSource,\n    options?: ReconstructionOptions\n  ): Promise<void>;\n\n  reconstructToStream(entry: FileEntry, chunkSource: ChunkSource): Promise<Readable>;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"It only has three public methods, but it will have many private functions depending on how complex you want the service to be. (Temporal reconstruction, in-place reconstruction, thresholds, validation, streaming...)"}),"\n",(0,s.jsx)(n.h3,{id:"chunksource",children:"ChunkSource"}),"\n",(0,s.jsxs)(n.p,{children:["As you can see above, every method needs a ",(0,s.jsx)(n.code,{children:"ChunkSource"}),", a special service that connects directly with your storage adapter, your memory, or your disk, depending on how you want your chunks managed."]}),"\n",(0,s.jsxs)(n.p,{children:["This is the abstraction for ",(0,s.jsx)(n.code,{children:"ChunkSource"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="TypeScript ChunkSource abstraction"',children:"interface ChunkSource {\n  getChunk(hash: string): Promise<Buffer>;\n\n  getChunks?(hashes: string[], options?: { concurrency?: number }): Promise<Map<string, Buffer>>;\n\n  streamChunks?(\n    hashes: string[],\n    options?: { concurrency?: number; preserveOrder?: boolean }\n  ): AsyncGenerator<{ hash: string; data: Readable }>;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The recommended implementations are: ",(0,s.jsx)(n.code,{children:"StorageChunkSource"}),", ",(0,s.jsx)(n.code,{children:"MemoryChunkSource"})," and ",(0,s.jsx)(n.code,{children:"DiskChunkSource"})," (First one will get chunks from remote storage, the second one from memory if chunks were downloaded first, and third one the same but from disk)"]}),"\n",(0,s.jsxs)(n.p,{children:["The recommended use for the reconstruction service is to try ",(0,s.jsx)(n.code,{children:"streamChunks"})," > ",(0,s.jsx)(n.code,{children:"getChunks"})," > ",(0,s.jsx)(n.code,{children:"getChunk"})," if they exist, for better performance."]}),"\n",(0,s.jsx)(n.h3,{id:"reconstructionoptions",children:"ReconstructionOptions"}),"\n",(0,s.jsx)(n.p,{children:"For a better user experience, customization and service performance, there are some recommended configuration parameters for the service:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"interface ReconstructionOptions {\n  forceRebuild?: boolean;\n  verifyAfterRebuild?: boolean;\n  inPlaceReconstructionThreshold?: number;\n  fileConcurrency?: number;\n  onProgress?: (\n    reconstructProgress: number,\n    diskSpeed: number,\n    networkProgress?: number,\n    networkSpeed?: number\n  ) => void;\n}\n"})}),"\n",(0,s.jsx)(n.h4,{id:"forcerebuild",children:(0,s.jsx)(n.code,{children:"forceRebuild"})}),"\n",(0,s.jsxs)(n.p,{children:["Force to rebuild even if hash file matches. (",(0,s.jsx)(n.code,{children:"boolean"}),")"]}),"\n",(0,s.jsx)(n.h4,{id:"verifyafterrebuild",children:(0,s.jsx)(n.code,{children:"verifyAfterRebuild"})}),"\n",(0,s.jsxs)(n.p,{children:["Verifies the reconstructed file hash after finishing. If hash does not match, an error is thrown. (",(0,s.jsx)(n.code,{children:"boolean"}),")"]}),"\n",(0,s.jsx)(n.h4,{id:"inplacereconstructionthreshold",children:(0,s.jsx)(n.code,{children:"inPlaceReconstructionThreshold"})}),"\n",(0,s.jsxs)(n.p,{children:["Minimum file size (in bytes) required to perform an ",(0,s.jsx)(n.strong,{children:"in-place reconstruction"})," instead of using a temporary file.\nDefault: ",(0,s.jsx)(n.code,{children:"400 * 1024 * 1024"})," (400 MB)."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"In-place reconstruction:"}),"\nThe existing file is opened and updated directly by overwriting only the modified or missing chunks."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:".tmp reconstruction:"}),"\nThe file is fully rebuilt in a temporary ",(0,s.jsx)(n.code,{children:".tmp"})," location using all chunks (new and existing), then replaced over the original file."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"When to use:"}),"\nIn-place reconstruction is recommended for ",(0,s.jsx)(n.strong,{children:"large files"}),", as it avoids rewriting the entire file and significantly reduces disk space usage.\nHowever, it may be ",(0,s.jsx)(n.strong,{children:"unsafe for certain formats"})," (e.g., ZIP archives or databases) that are sensitive to partial writes or corruption.\nTo disable in-place reconstruction entirely, set this value to ",(0,s.jsx)(n.code,{children:"0"}),"."]}),"\n",(0,s.jsx)(n.h4,{id:"fileconcurrency",children:(0,s.jsx)(n.code,{children:"fileConcurrency"})}),"\n",(0,s.jsxs)(n.p,{children:["How many files will reconstruct concurrently (default value is 5). (",(0,s.jsx)(n.code,{children:"number"}),")"]}),"\n",(0,s.jsx)(n.h4,{id:"onprogress",children:(0,s.jsx)(n.code,{children:"onProgress"})}),"\n",(0,s.jsx)(n.p,{children:"Callback that returns disk usage and optional network speed (only for storage chunk sources via streaming download-reconstruction)"})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>c});var i=r(6540);const s={},t=i.createContext(s);function o(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);