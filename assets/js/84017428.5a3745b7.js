"use strict";(globalThis.webpackChunkrac_delta_docs=globalThis.webpackChunkrac_delta_docs||[]).push([[5389],{8453:(e,r,n)=>{n.d(r,{R:()=>i,x:()=>o});var s=n(6540);const c={},t=s.createContext(c);function i(e){const r=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function o(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:i(e.components),s.createElement(t.Provider,{value:r},e.children)}},8971:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>d,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"reference/Rust/services/reconstruction-service","title":"ReconstructionService","description":"Service responsible for reconstructing files from chunks using any ChunkSource.","source":"@site/docs/reference/Rust/services/reconstruction-service.md","sourceDirName":"reference/Rust/services","slug":"/reference/Rust/services/reconstruction-service","permalink":"/rac-delta-docs/reference/Rust/services/reconstruction-service","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"title":"ReconstructionService","description":"Service responsible for reconstructing files from chunks using any ChunkSource.","sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"DeltaService","permalink":"/rac-delta-docs/reference/Rust/services/delta-service"},"next":{"title":"Chunk Sources","permalink":"/rac-delta-docs/category/chunk-sources-1"}}');var c=n(4848),t=n(8453);const i={title:"ReconstructionService",description:"Service responsible for reconstructing files from chunks using any ChunkSource.",sidebar_position:4},o="ReconstructionService",d={},l=[{value:"Methods",id:"methods",level:2},{value:"ReconstructionError",id:"reconstructionerror",level:2},{value:"ReconstructionOptions",id:"reconstructionoptions",level:2},{value:"Method Details",id:"method-details",level:2},{value:"<code>reconstruct_file(entry, output_path, chunk_source, options, cb)</code>",id:"reconstruct_fileentry-output_path-chunk_source-options-cb",level:3},{value:"<code>reconstruct_all(plan, output_dir, chunk_source, options)</code>",id:"reconstruct_allplan-output_dir-chunk_source-options",level:3},{value:"<code>reconstruct_to_stream(entry, chunk_source)</code>",id:"reconstruct_to_streamentry-chunk_source",level:3},{value:"Related",id:"related",level:2}];function h(e){const r={a:"a",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)(r.header,{children:(0,c.jsx)(r.h1,{id:"reconstructionservice",children:"ReconstructionService"})}),"\n",(0,c.jsxs)(r.p,{children:[(0,c.jsx)(r.code,{children:"ReconstructionService"})," defines the primary interface responsible for ",(0,c.jsx)(r.strong,{children:"reconstructing files from their chunks"}),", either on disk or as a stream.",(0,c.jsx)(r.br,{}),"\n","This service communicates directly with a ",(0,c.jsx)(r.a,{href:"../chunk-sources/chunk-source",children:(0,c.jsx)(r.code,{children:"ChunkSource"})})," to obtain the required data and reassemble the file."]}),"\n",(0,c.jsx)(r.p,{children:"It serves as the core component of the restoration process within rac-delta."}),"\n",(0,c.jsx)(r.hr,{}),"\n",(0,c.jsx)(r.h2,{id:"methods",children:"Methods"}),"\n",(0,c.jsxs)(r.table,{children:[(0,c.jsx)(r.thead,{children:(0,c.jsxs)(r.tr,{children:[(0,c.jsx)(r.th,{children:"Method"}),(0,c.jsx)(r.th,{children:"Returns"}),(0,c.jsx)(r.th,{children:"Description"})]})}),(0,c.jsxs)(r.tbody,{children:[(0,c.jsxs)(r.tr,{children:[(0,c.jsx)(r.td,{children:(0,c.jsx)(r.code,{children:"reconstruct_file(entry, output_path, chunk_source, options, cb)"})}),(0,c.jsx)(r.td,{children:(0,c.jsx)(r.code,{children:"Result<(), ReconstructionError>"})}),(0,c.jsx)(r.td,{children:"Reconstruct a single file in disk."})]}),(0,c.jsxs)(r.tr,{children:[(0,c.jsx)(r.td,{children:(0,c.jsx)(r.code,{children:"reconstruct_all(plan, output_dir, chunk_source, options)"})}),(0,c.jsx)(r.td,{children:(0,c.jsx)(r.code,{children:"Result<(), ReconstructionError>"})}),(0,c.jsx)(r.td,{children:"Reconstruct all files from a DeltaPlan in disk."})]}),(0,c.jsxs)(r.tr,{children:[(0,c.jsx)(r.td,{children:(0,c.jsx)(r.code,{children:"reconstruct_to_stream(entry, chunk_source)"})}),(0,c.jsx)(r.td,{children:(0,c.jsx)(r.code,{children:"Result<Pin<Box<dyn AsyncRead + Send + Sync>>, ReconstructionError>"})}),(0,c.jsx)(r.td,{children:"Reconstruct a file in memory and returns it as a Readable stream."})]})]})]}),"\n",(0,c.jsx)(r.hr,{}),"\n",(0,c.jsx)(r.h2,{id:"reconstructionerror",children:"ReconstructionError"}),"\n",(0,c.jsxs)(r.p,{children:["Custom error enum for results of ReconstructionService. (Uses ",(0,c.jsx)(r.code,{children:"thiserror"}),")"]}),"\n",(0,c.jsx)(r.pre,{children:(0,c.jsx)(r.code,{className:"language-rust",children:'pub enum ReconstructionError {\n    #[error("I/O error: {0}")]\n    Io(#[from] std::io::Error),\n\n    #[error("Chunk \'{0}\' not found")]\n    ChunkNotFound(String),\n\n    #[error("Hash mismatch for file \'{0}\'")]\n    HashMismatch(String),\n\n    #[error("Failed to read chunk \'{0}\'")]\n    ChunkReadError(String),\n\n    #[error("Reconstruction failed: {0}")]\n    Other(String),\n}\n'})}),"\n",(0,c.jsx)(r.hr,{}),"\n",(0,c.jsx)(r.h2,{id:"reconstructionoptions",children:"ReconstructionOptions"}),"\n",(0,c.jsx)(r.p,{children:"Options for the reconstruction progress:"}),"\n",(0,c.jsx)(r.pre,{children:(0,c.jsx)(r.code,{className:"language-rust",children:"pub struct ReconstructionOptions {\n    pub force_rebuild: Option<bool>,\n    pub verify_after_rebuild: Option<bool>,\n    pub in_place_reconstruction_threshold: Option<u64>,\n    pub file_concurrency: Option<usize>,\n    pub on_progress: Option<Arc<dyn Fn(f64, usize, Option<f64>, Option<usize>) + Send + Sync>>,\n}\n"})}),"\n",(0,c.jsxs)(r.table,{children:[(0,c.jsx)(r.thead,{children:(0,c.jsxs)(r.tr,{children:[(0,c.jsx)(r.th,{children:"Parameter"}),(0,c.jsx)(r.th,{children:"Type"}),(0,c.jsx)(r.th,{children:"Description"})]})}),(0,c.jsxs)(r.tbody,{children:[(0,c.jsxs)(r.tr,{children:[(0,c.jsx)(r.td,{children:(0,c.jsx)(r.code,{children:"force_rebuild"})}),(0,c.jsx)(r.td,{children:(0,c.jsx)(r.code,{children:"Option<bool>"})}),(0,c.jsx)(r.td,{children:"Force to rebuild even if hash file matches."})]}),(0,c.jsxs)(r.tr,{children:[(0,c.jsx)(r.td,{children:(0,c.jsx)(r.code,{children:"verify_after_rebuild"})}),(0,c.jsx)(r.td,{children:(0,c.jsx)(r.code,{children:"Option<bool>"})}),(0,c.jsx)(r.td,{children:"Verifies the reconstructed file hash after finishing. If hash does not match, an error is thrown."})]}),(0,c.jsxs)(r.tr,{children:[(0,c.jsx)(r.td,{children:(0,c.jsx)(r.code,{children:"in_place_reconstruction_threshold"})}),(0,c.jsx)(r.td,{children:(0,c.jsx)(r.code,{children:"Option<u64>"})}),(0,c.jsxs)(r.td,{children:["Minimum file size (in bytes) required to perform an ",(0,c.jsx)(r.strong,{children:"in-place reconstruction"})," instead of using a temporary file."]})]}),(0,c.jsxs)(r.tr,{children:[(0,c.jsx)(r.td,{children:(0,c.jsx)(r.code,{children:"file_concurrency"})}),(0,c.jsx)(r.td,{children:(0,c.jsx)(r.code,{children:"Option<usize>"})}),(0,c.jsx)(r.td,{children:"How many files will reconstruct concurrently (default value is 5)."})]}),(0,c.jsxs)(r.tr,{children:[(0,c.jsx)(r.td,{children:(0,c.jsx)(r.code,{children:"on_progress"})}),(0,c.jsx)(r.td,{children:(0,c.jsx)(r.code,{children:"Option<Arc<dyn Fn(f64, usize, Option<f64>, Option<usize>) + Send + Sync>>"})}),(0,c.jsx)(r.td,{children:"Callback that returns disk usage and optional network speed (only for storage chunk sources via streaming download-reconstruction)."})]})]})]}),"\n",(0,c.jsx)(r.hr,{}),"\n",(0,c.jsx)(r.h2,{id:"method-details",children:"Method Details"}),"\n",(0,c.jsx)(r.h3,{id:"reconstruct_fileentry-output_path-chunk_source-options-cb",children:(0,c.jsx)(r.code,{children:"reconstruct_file(entry, output_path, chunk_source, options, cb)"})}),"\n",(0,c.jsxs)(r.p,{children:["Reconstruct a single file from a ",(0,c.jsx)(r.code,{children:"FileEntry"})," in disk."]}),"\n",(0,c.jsx)(r.p,{children:(0,c.jsx)(r.strong,{children:"Parameters:"})}),"\n",(0,c.jsxs)(r.table,{children:[(0,c.jsx)(r.thead,{children:(0,c.jsxs)(r.tr,{children:[(0,c.jsx)(r.th,{children:"Name"}),(0,c.jsx)(r.th,{children:"Type"}),(0,c.jsx)(r.th,{children:"Description"})]})}),(0,c.jsxs)(r.tbody,{children:[(0,c.jsxs)(r.tr,{children:[(0,c.jsx)(r.td,{children:(0,c.jsx)(r.code,{children:"entry"})}),(0,c.jsx)(r.td,{children:(0,c.jsx)(r.code,{children:"&FileEntry"})}),(0,c.jsxs)(r.td,{children:["The ",(0,c.jsx)(r.code,{children:"FileEntry"})," containing the list of chunks and path of the file."]})]}),(0,c.jsxs)(r.tr,{children:[(0,c.jsx)(r.td,{children:(0,c.jsx)(r.code,{children:"outputPath"})}),(0,c.jsx)(r.td,{children:(0,c.jsx)(r.code,{children:"&Path"})}),(0,c.jsx)(r.td,{children:"The path where the file will be reconstructed."})]}),(0,c.jsxs)(r.tr,{children:[(0,c.jsx)(r.td,{children:(0,c.jsx)(r.code,{children:"chunkSource"})}),(0,c.jsx)(r.td,{children:(0,c.jsx)(r.code,{children:"&dyn ChunkSource"})}),(0,c.jsx)(r.td,{children:"The chunk source implementation where the chunks will be retrieved."})]}),(0,c.jsxs)(r.tr,{children:[(0,c.jsx)(r.td,{children:(0,c.jsx)(r.code,{children:"options"})}),(0,c.jsx)(r.td,{children:(0,c.jsx)(r.code,{children:"Option<&ReconstructionOptions>"})}),(0,c.jsx)(r.td,{children:"Options for reconstruction."})]}),(0,c.jsxs)(r.tr,{children:[(0,c.jsx)(r.td,{children:(0,c.jsx)(r.code,{children:"cb"})}),(0,c.jsx)(r.td,{children:(0,c.jsx)(r.code,{children:"Option<FileProgressCallback>"})}),(0,c.jsx)(r.td,{children:"Optional callback for progress."})]})]})]}),"\n",(0,c.jsx)(r.pre,{children:(0,c.jsx)(r.code,{className:"language-rust",children:"pub type FileProgressCallback = Arc<dyn Fn(f64, usize, Option<usize>) + Send + Sync>;\n"})}),"\n",(0,c.jsxs)(r.p,{children:[(0,c.jsx)(r.strong,{children:"Returns:"})," ",(0,c.jsx)(r.code,{children:"Result<(), ReconstructionError"})]}),"\n",(0,c.jsx)(r.hr,{}),"\n",(0,c.jsx)(r.h3,{id:"reconstruct_allplan-output_dir-chunk_source-options",children:(0,c.jsx)(r.code,{children:"reconstruct_all(plan, output_dir, chunk_source, options)"})}),"\n",(0,c.jsx)(r.p,{children:"Reconstruct all files from given DeltaPlan in disk."}),"\n",(0,c.jsx)(r.p,{children:(0,c.jsx)(r.strong,{children:"Parameters:"})}),"\n",(0,c.jsxs)(r.table,{children:[(0,c.jsx)(r.thead,{children:(0,c.jsxs)(r.tr,{children:[(0,c.jsx)(r.th,{children:"Name"}),(0,c.jsx)(r.th,{children:"Type"}),(0,c.jsx)(r.th,{children:"Description"})]})}),(0,c.jsxs)(r.tbody,{children:[(0,c.jsxs)(r.tr,{children:[(0,c.jsx)(r.td,{children:(0,c.jsx)(r.code,{children:"plan"})}),(0,c.jsx)(r.td,{children:(0,c.jsx)(r.code,{children:"&DeltaPlan"})}),(0,c.jsxs)(r.td,{children:["The ",(0,c.jsx)(r.code,{children:"DeltaPlan"})," containing the files to be reconstructed."]})]}),(0,c.jsxs)(r.tr,{children:[(0,c.jsx)(r.td,{children:(0,c.jsx)(r.code,{children:"output_dir"})}),(0,c.jsx)(r.td,{children:(0,c.jsx)(r.code,{children:"&Path"})}),(0,c.jsx)(r.td,{children:"The path where the files will be reconstructed."})]}),(0,c.jsxs)(r.tr,{children:[(0,c.jsx)(r.td,{children:(0,c.jsx)(r.code,{children:"chunk_source"})}),(0,c.jsx)(r.td,{children:(0,c.jsx)(r.code,{children:"Arc<dyn ChunkSource>"})}),(0,c.jsx)(r.td,{children:"The chunk source implementation where the chunks will be retrieved."})]}),(0,c.jsxs)(r.tr,{children:[(0,c.jsx)(r.td,{children:(0,c.jsx)(r.code,{children:"options"})}),(0,c.jsx)(r.td,{children:(0,c.jsx)(r.code,{children:"Option<&ReconstructionOptions>"})}),(0,c.jsx)(r.td,{children:"Options for reconstruction."})]})]})]}),"\n",(0,c.jsxs)(r.p,{children:[(0,c.jsx)(r.strong,{children:"Returns:"})," ",(0,c.jsx)(r.code,{children:"Result<(), ReconstructionError>"})]}),"\n",(0,c.jsx)(r.hr,{}),"\n",(0,c.jsx)(r.h3,{id:"reconstruct_to_streamentry-chunk_source",children:(0,c.jsx)(r.code,{children:"reconstruct_to_stream(entry, chunk_source)"})}),"\n",(0,c.jsx)(r.p,{children:"Reconstruct a file in memory and returns it as a stream."}),"\n",(0,c.jsx)(r.p,{children:(0,c.jsx)(r.strong,{children:"Parameters:"})}),"\n",(0,c.jsxs)(r.table,{children:[(0,c.jsx)(r.thead,{children:(0,c.jsxs)(r.tr,{children:[(0,c.jsx)(r.th,{children:"Name"}),(0,c.jsx)(r.th,{children:"Type"}),(0,c.jsx)(r.th,{children:"Description"})]})}),(0,c.jsxs)(r.tbody,{children:[(0,c.jsxs)(r.tr,{children:[(0,c.jsx)(r.td,{children:(0,c.jsx)(r.code,{children:"entry"})}),(0,c.jsx)(r.td,{children:(0,c.jsx)(r.code,{children:"FileEntry"})}),(0,c.jsxs)(r.td,{children:["The ",(0,c.jsx)(r.code,{children:"FileEntry"})," containing the list of chunks and path of the file."]})]}),(0,c.jsxs)(r.tr,{children:[(0,c.jsx)(r.td,{children:(0,c.jsx)(r.code,{children:"chunk_source"})}),(0,c.jsx)(r.td,{children:(0,c.jsx)(r.code,{children:"Arc<dyn ChunkSource + Send + Sync>"})}),(0,c.jsx)(r.td,{children:"The chunk source implementation where the chunks will be retrieved."})]})]})]}),"\n",(0,c.jsxs)(r.p,{children:[(0,c.jsx)(r.strong,{children:"Returns:"})," ",(0,c.jsx)(r.code,{children:"Result<Pin<Box<dyn AsyncRead + Send + Sync>>, ReconstructionError>"})]}),"\n",(0,c.jsx)(r.hr,{}),"\n",(0,c.jsx)(r.h2,{id:"related",children:"Related"}),"\n",(0,c.jsxs)(r.ul,{children:["\n",(0,c.jsx)(r.li,{children:(0,c.jsx)(r.a,{href:"/reference/Rust/models/delta-plan",children:"DeltaPlan"})}),"\n",(0,c.jsx)(r.li,{children:(0,c.jsx)(r.a,{href:"/reference/Rust/models/file-entry",children:"FileEntry"})}),"\n",(0,c.jsx)(r.li,{children:(0,c.jsx)(r.a,{href:"/reference/Rust/chunk-sources/chunk-source",children:"ChunkSource"})}),"\n"]})]})}function u(e={}){const{wrapper:r}={...(0,t.R)(),...e.components};return r?(0,c.jsx)(r,{...e,children:(0,c.jsx)(h,{...e})}):h(e)}}}]);