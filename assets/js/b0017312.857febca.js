"use strict";(globalThis.webpackChunkrac_delta_docs=globalThis.webpackChunkrac_delta_docs||[]).push([[8103],{1470:(e,n,t)=>{t.d(n,{A:()=>k});var r=t(6540),s=t(4164),o=t(7559),i=t(3104),l=t(6347),a=t(205),d=t(7485),c=t(1682),h=t(679);function u(e){return r.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}function p(e){const{values:n,children:t}=e;return(0,r.useMemo)(()=>{const e=n??function(e){return u(e).map(({props:{value:e,label:n,attributes:t,default:r}})=>({value:e,label:n,attributes:t,default:r}))}(t);return function(e){const n=(0,c.XI)(e,(e,n)=>e.value===n.value);if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map(e=>e.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e},[n,t])}function x({value:e,tabValues:n}){return n.some(n=>n.value===e)}function m({queryString:e=!1,groupId:n}){const t=(0,l.W6)(),s=function({queryString:e=!1,groupId:n}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,d.aZ)(s),(0,r.useCallback)(e=>{if(!s)return;const n=new URLSearchParams(t.location.search);n.set(s,e),t.replace({...t.location,search:n.toString()})},[s,t])]}function f(e){const{defaultValue:n,queryString:t=!1,groupId:s}=e,o=p(e),[i,l]=(0,r.useState)(()=>function({defaultValue:e,tabValues:n}){if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!x({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map(e=>e.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const t=n.find(e=>e.default)??n[0];if(!t)throw new Error("Unexpected error: 0 tabValues");return t.value}({defaultValue:n,tabValues:o})),[d,c]=m({queryString:t,groupId:s}),[u,f]=function({groupId:e}){const n=function(e){return e?`docusaurus.tab.${e}`:null}(e),[t,s]=(0,h.Dv)(n);return[t,(0,r.useCallback)(e=>{n&&s.set(e)},[n,s])]}({groupId:s}),w=(()=>{const e=d??u;return x({value:e,tabValues:o})?e:null})();(0,a.A)(()=>{w&&l(w)},[w]);return{selectedValue:i,selectValue:(0,r.useCallback)(e=>{if(!x({value:e,tabValues:o}))throw new Error(`Can't select invalid tab value=${e}`);l(e),c(e),f(e)},[c,f,o]),tabValues:o}}var w=t(2303);const j={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var g=t(4848);function y({className:e,block:n,selectedValue:t,selectValue:r,tabValues:o}){const l=[],{blockElementScrollPositionUntilNextRender:a}=(0,i.a_)(),d=e=>{const n=e.currentTarget,s=l.indexOf(n),i=o[s].value;i!==t&&(a(n),r(i))},c=e=>{let n=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const t=l.indexOf(e.currentTarget)+1;n=l[t]??l[0];break}case"ArrowLeft":{const t=l.indexOf(e.currentTarget)-1;n=l[t]??l[l.length-1];break}}n?.focus()};return(0,g.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.A)("tabs",{"tabs--block":n},e),children:o.map(({value:e,label:n,attributes:r})=>(0,g.jsx)("li",{role:"tab",tabIndex:t===e?0:-1,"aria-selected":t===e,ref:e=>{l.push(e)},onKeyDown:c,onClick:d,...r,className:(0,s.A)("tabs__item",j.tabItem,r?.className,{"tabs__item--active":t===e}),children:n??e},e))})}function b({lazy:e,children:n,selectedValue:t}){const o=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const e=o.find(e=>e.props.value===t);return e?(0,r.cloneElement)(e,{className:(0,s.A)("margin-top--md",e.props.className)}):null}return(0,g.jsx)("div",{className:"margin-top--md",children:o.map((e,n)=>(0,r.cloneElement)(e,{key:n,hidden:e.props.value!==t}))})}function v(e){const n=f(e);return(0,g.jsxs)("div",{className:(0,s.A)(o.G.tabs.container,"tabs-container",j.tabList),children:[(0,g.jsx)(y,{...n,...e}),(0,g.jsx)(b,{...n,...e})]})}function k(e){const n=(0,w.A)();return(0,g.jsx)(v,{...e,children:u(e.children)},String(n))}},6705:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>h,contentTitle:()=>c,default:()=>x,frontMatter:()=>d,metadata:()=>r,toc:()=>u});const r=JSON.parse('{"id":"usage/downloading","title":"Downloading","description":"One of the main operations of rac-delta is downloading new updates from your builds or directories, downloading new chunks and reconstructing files.","source":"@site/docs/usage/downloading.mdx","sourceDirName":"usage","slug":"/usage/downloading","permalink":"/rac-delta-docs/usage/downloading","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Uploading","permalink":"/rac-delta-docs/usage/uploading"},"next":{"title":"Services","permalink":"/rac-delta-docs/usage/services"}}');var s=t(4848),o=t(8453),i=t(1470),l=t(9365),a=t(3457);const d={sidebar_position:3},c="Downloading",h={},u=[{value:"Download pipeline",id:"download-pipeline",level:2},{value:"Update strategies",id:"update-strategies",level:2},{value:"Download all first to disk",id:"download-all-first-to-disk",level:3},{value:"Download all first to memory",id:"download-all-first-to-memory",level:3},{value:"Stream from network",id:"stream-from-network",level:3},{value:"How reconstruction works",id:"how-reconstruction-works",level:2},{value:"Pipeline helpers",id:"pipeline-helpers",level:2}];function p(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"downloading",children:"Downloading"})}),"\n",(0,s.jsx)(n.p,{children:"One of the main operations of rac-delta is downloading new updates from your builds or directories, downloading new chunks and reconstructing files."}),"\n",(0,s.jsx)(n.p,{children:"You can use rac-delta SDK to totally download a build or just changes."}),"\n",(0,s.jsx)(n.h2,{id:"download-pipeline",children:"Download pipeline"}),"\n",(0,s.jsx)(n.p,{children:"For this, rac-delta SDK provides a download pipeline which already implements all steps to automatically download new builds to your storage."}),"\n",(0,s.jsxs)(i.A,{children:[(0,s.jsxs)(l.A,{value:"node",label:"Node.js",children:[(0,s.jsx)("h4",{children:"Basic pipeline usage:"}),(0,s.jsx)(a.A,{className:"language-ts",children:"\n  const remoteIndexToUse = undefined;\n\n  await racDeltaClient.pipelines.download.execute(\n      /my/path/dir,\n      UpdateStrategy.DownloadAllFirstToDisk,\n      remoteIndexToUse,\n      {\n          chunksSavePath: 'tmp',\n          useExistingIndex: false,\n          force: false,\n          fileReconstructionConcurrency: 4,\n          inPlaceReconstructionThreshold: 400 * 1024 * 1024,\n          onStateChange: (state) => {\n              console.log(state);\n          },\n          onProgress: (type, progress, diskUsage, speed) => {\n              // print and format progress\n          }\n      }\n  );\n\n"}),(0,s.jsx)("h4",{children:"Parameters:"}),(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"path"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"string"})}),(0,s.jsx)(n.td,{children:"The path to your local build that will be updated (relative or absolute path)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"updateStrategy"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"UpdateStrategy"})}),(0,s.jsx)(n.td,{children:'The strategy that will be used to download and reconstruct local files. See "Update strategies" below for more info.'})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"remote rd-index"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"RDIndex"})}),(0,s.jsx)(n.td,{children:"The rd-index.json as RDIndex object that will be used as remote index, if none provided, the pipeline will try to download it from your storage"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"download options"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"DownloadOptions"})}),(0,s.jsx)(n.td,{children:(0,s.jsxs)("table",{children:[" ",(0,s.jsxs)("thead",{children:[" ",(0,s.jsxs)("tr",{children:[" ",(0,s.jsx)("th",{children:"Parameter"})," ",(0,s.jsx)("th",{children:"Type"})," ",(0,s.jsx)("th",{children:"Description"})," "]})," "]})," ",(0,s.jsxs)("tbody",{children:[" ",(0,s.jsxs)("tr",{children:[" ",(0,s.jsx)("td",{children:"chunksSavePath"})," ",(0,s.jsx)("td",{children:(0,s.jsx)("code",{children:"string"})})," ",(0,s.jsx)("td",{children:'The path where the chunks downloaded will be temporally saved in case the "Download all first to disk" strategy is selected'})," "]})," ",(0,s.jsxs)("tr",{children:[" ",(0,s.jsx)("td",{children:"useExistingIndex"}),(0,s.jsx)("td",{children:(0,s.jsx)("code",{children:"boolean"})}),(0,s.jsx)("td",{children:"if true will try to find existing rd-index.json in given path, to use it as local rd-index"})," "]})," ",(0,s.jsxs)("tr",{children:[" ",(0,s.jsx)("td",{children:"force"})," ",(0,s.jsx)("td",{children:(0,s.jsx)("code",{children:"boolean"})})," ",(0,s.jsx)("td",{children:"If true, will download everything"})," "]})," ",(0,s.jsxs)("tr",{children:[" ",(0,s.jsx)("td",{children:"fileReconstructionConcurrency"})," ",(0,s.jsx)("td",{children:(0,s.jsx)("code",{children:"number"})})," ",(0,s.jsx)("td",{children:"Concurrency limit for reconstruction process, will use default maxConcurrency value from client if none provided"})," "]})," ",(0,s.jsxs)("tr",{children:[(0,s.jsx)("td",{children:"inPlaceReconstructionThreshold"})," ",(0,s.jsx)("td",{children:(0,s.jsx)("code",{children:"number"})})," ",(0,s.jsx)("td",{children:"The file size (in bytes) limit to use in-place reconstruction instead of .tmp reconstruction. Default value is 400MB. in-place reconstruction is recommended for large files, but could lead to corruption, if you don't want any in-place reconstruction simply set this to 0"}),"  "]})," ",(0,s.jsxs)("tr",{children:[" ",(0,s.jsx)("td",{children:"onStateChange"}),(0,s.jsx)("td",{children:(0,s.jsx)("code",{children:"(state: DownloadState) => void"})})," ",(0,s.jsxs)("td",{children:["Callback that will notify when the pipeline changes its state. Available states are: ",(0,s.jsx)(n.strong,{children:"downloading"}),", ",(0,s.jsx)(n.strong,{children:"reconstructing"}),", ",(0,s.jsx)(n.strong,{children:"cleaning"})," and ",(0,s.jsx)(n.strong,{children:"scanning"})]})," "]})," ",(0,s.jsxs)("tr",{children:[(0,s.jsx)("td",{children:"onProgress"}),(0,s.jsx)("td",{children:(0,s.jsx)("code",{children:'(type: "deleting" | "download" | "reconstructing", progress: number, diskUsage?: number, speed?: number) => void'})}),(0,s.jsx)("td",{children:"Callback that will notify the progress of the download operations. It will notify downloading progress and network speed, reconstructing progress and disk speed, and deleting remote chunks progress"})]})," "]})," "]})})]})]})]})]}),(0,s.jsxs)(l.A,{value:"rust",label:"Rust",children:[(0,s.jsx)("h4",{children:"Basic pipeline usage:"}),(0,s.jsx)(a.A,{className:"language-rust",children:'\n  let remote_index_to_use: Option<RDIndex> = None;\n\n  match client.pipelines.download {\n      DownloadPipelineBundle::Hash(pipeline) => {\n          pipeline\n              .execute(\n                  Path::new("my/dir"),\n                  UpdateStrategy::DownloadAllFirstToDisk,\n                  remote_index_to_use,\n                  Some(DownloadOptions {\n                      chunks_save_path: Some(Path::new("dir/.tmp").to_path_buf()),\n                      use_existing_index: Some(false),\n                      force: Some(false),\n                      file_reconstruction_concurrency: Some(4),\n                      in_place_reconstruction_threshold: Some(400 * 1024 * 1024),\n                      on_state_change: Some(std::sync::Arc::new(|state| {\n                          println!("Download state: {:?}", state);\n                      })),\n                      on_progress: Some(std::sync::Arc::new(\n                          |progress_type, progress, disk_usage, speed| {\n                              // Print and format progress\n                          },\n                      )),\n                  }),\n              )\n              .await?;\n      }\n      DownloadPipelineBundle::Url(_p) => {\n          // none for SSH\n      }\n  }\n  '}),(0,s.jsx)("h4",{children:"Parameters:"}),(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"path"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Path"})}),(0,s.jsx)(n.td,{children:"The path to your local build that will be updated (relative or absolute path)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"updateStrategy"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"UpdateStrategy"})}),(0,s.jsx)(n.td,{children:'The strategy that will be used to download and reconstruct local files. See "Update strategies" below for more info.'})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"remote rd-index"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"RDIndex"})}),(0,s.jsx)(n.td,{children:"The rd-index.json as RDIndex object that will be used as remote index, if none provided, the pipeline will try to download it from your storage"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"download options"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"DownloadOptions"})}),(0,s.jsx)(n.td,{children:(0,s.jsxs)("table",{children:[" ",(0,s.jsxs)("thead",{children:[" ",(0,s.jsxs)("tr",{children:[" ",(0,s.jsx)("th",{children:"Parameter"})," ",(0,s.jsx)("th",{children:"Type"})," ",(0,s.jsx)("th",{children:"Description"})," "]})," "]})," ",(0,s.jsxs)("tbody",{children:[" ",(0,s.jsxs)("tr",{children:[" ",(0,s.jsx)("td",{children:"chunks_save_path"})," ",(0,s.jsx)("td",{children:(0,s.jsx)("code",{children:"Option<PathBuf>"})})," ",(0,s.jsx)("td",{children:'The path where the chunks downloaded will be temporally saved in case the "Download all first to disk" strategy is selected'})," "]})," ",(0,s.jsxs)("tr",{children:[" ",(0,s.jsx)("td",{children:"use_existing_index"}),(0,s.jsx)("td",{children:(0,s.jsx)("code",{children:"Option<bool>"})}),(0,s.jsx)("td",{children:"if true will try to find existing rd-index.json in given path, to use it as local rd-index"})," "]})," ",(0,s.jsxs)("tr",{children:[" ",(0,s.jsx)("td",{children:"force"})," ",(0,s.jsx)("td",{children:(0,s.jsx)("code",{children:"Option<bool>"})})," ",(0,s.jsx)("td",{children:"If true, will download everything"})," "]})," ",(0,s.jsxs)("tr",{children:[" ",(0,s.jsx)("td",{children:"file_reconstruction_concurrency"})," ",(0,s.jsx)("td",{children:(0,s.jsx)("code",{children:"Option<usize>"})})," ",(0,s.jsx)("td",{children:"Concurrency limit for reconstruction process, will use default maxConcurrency value from client if none provided"})," "]})," ",(0,s.jsxs)("tr",{children:[(0,s.jsx)("td",{children:"in_place_reconstruction_threshold"})," ",(0,s.jsx)("td",{children:(0,s.jsx)("code",{children:"Option<u64>"})})," ",(0,s.jsx)("td",{children:"The file size (in bytes) limit to use in-place reconstruction instead of .tmp reconstruction. Default value is 400MB. in-place reconstruction is recommended for large files, but could lead to corruption, if you don't want any in-place reconstruction simply set this to 0"}),"  "]})," ",(0,s.jsxs)("tr",{children:[" ",(0,s.jsx)("td",{children:"on_state_change"}),(0,s.jsx)("td",{children:(0,s.jsx)("code",{children:"Option<Arc<dyn Fn(DownloadState) + Send + Sync + 'static, Global>>"})})," ",(0,s.jsxs)("td",{children:["Callback that will notify when the pipeline changes its state. Available states are: ",(0,s.jsx)(n.strong,{children:"downloading"}),", ",(0,s.jsx)(n.strong,{children:"reconstructing"}),", ",(0,s.jsx)(n.strong,{children:"cleaning"})," and ",(0,s.jsx)(n.strong,{children:"scanning"})]})," "]})," ",(0,s.jsxs)("tr",{children:[(0,s.jsx)("td",{children:"on_progress"}),(0,s.jsx)("td",{children:(0,s.jsx)("code",{children:"Option<Arc<dyn Fn(DownloadPhase, f64, Option<f64>, Option<f64>) + Send + Sync + 'static, Global>>"})}),(0,s.jsx)("td",{children:"Callback that will notify the progress of the download operations. It will notify downloading progress and network speed, reconstructing progress and disk speed, and deleting remote chunks progress"})]})," "]})," "]})})]})]})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"This will automatically generate or use existing local rd-index, will get remote rd-index if none provided, and download and reconstruct files from the update in your configured storage."}),"\n",(0,s.jsx)(n.h2,{id:"update-strategies",children:"Update strategies"}),"\n",(0,s.jsx)(n.p,{children:"The download pipeline provides three different update strategies that will affect how chunks are stored and how files are reconstructed."}),"\n",(0,s.jsx)(n.h3,{id:"download-all-first-to-disk",children:"Download all first to disk"}),"\n",(0,s.jsxs)(n.p,{children:["Using ",(0,s.jsx)(n.code,{children:"UpdateStrategy.DownloadAllFirstToDisk"})," will do exactly what it means, will download all chunks to a temporal directory on your disk, and then reconstruct files from there, making it a good option for slow internet but fast disk speed."]}),"\n",(0,s.jsx)(n.admonition,{title:"Note",type:"tip",children:(0,s.jsxs)(n.p,{children:["When using this strategy, you must supply a chunk save path under ",(0,s.jsx)(n.code,{children:"DownloadOptions"})]})}),"\n",(0,s.jsx)(n.h3,{id:"download-all-first-to-memory",children:"Download all first to memory"}),"\n",(0,s.jsxs)(n.p,{children:["Similar to disk, using ",(0,s.jsx)(n.code,{children:"UpdateStrategy.DownloadAllFirstToMemory"})," will download all chunks first to memory, and then reconstruct files from there. This is the fastest option, as will directly reconstruct after download with no extra steps, but is only recommended for small downloads."]}),"\n",(0,s.jsx)(n.h3,{id:"stream-from-network",children:"Stream from network"}),"\n",(0,s.jsxs)(n.p,{children:["This strategy ",(0,s.jsx)(n.code,{children:"UpdateStrategy.StreamFromNetwork"})," will stream chunks from your storage and reconstruct files concurrently, this strategy will not use memory and it is perfect for low memory machines and fast connection. This is the recommended strategy."]}),"\n",(0,s.jsx)(n.h2,{id:"how-reconstruction-works",children:"How reconstruction works"}),"\n",(0,s.jsxs)(n.p,{children:["For file reconstruction, rac-delta will use existing chunks + new chunks to reconstruct. It will reconstruct the file in a ",(0,s.jsx)(n.code,{children:"file.tmp"})," path and once it is completed, will override the original file."]}),"\n",(0,s.jsxs)(n.p,{children:["If ",(0,s.jsx)(n.code,{children:"inPlaceReconstructionThreshold"})," is set, it will reconstruct in-place instead of .tmp for the size specified, it is recommended to use in-place reconstruction for large files, as .tmp would require some extra disk space, but using in-place could lead to corruption of some file types, like .zip or video."]}),"\n",(0,s.jsxs)(n.p,{children:["For more info, see ",(0,s.jsx)(n.a,{href:"/core/services#reconstruction-service",children:"reconstruction service"})]}),"\n",(0,s.jsx)(n.h2,{id:"pipeline-helpers",children:"Pipeline helpers"}),"\n",(0,s.jsx)(n.p,{children:"In order to achieve the correct download and patching of the directory using rac-delta, the download pipeline uses internal methods that uses rac-delta services for downloading, index comparison, reconstruction, etc..."}),"\n",(0,s.jsx)(n.p,{children:"If you don't want to use the default execute method, you can create your own pipeline using those helpers and services."}),"\n",(0,s.jsxs)(i.A,{children:[(0,s.jsxs)(l.A,{value:"node",label:"Node.js",children:[(0,s.jsx)("h4",{children:"Example usage of pipeline helpers:"}),(0,s.jsx)(a.A,{className:"language-ts",children:"\n  const racDeltaClient = new RacDeltaClient({\n  chunkSize: 1024 * 1024,\n  maxConcurrency: 6,\n  storage: {\n      type: 'ssh',\n      host: 'localhost',\n      pathPrefix: '/root/upload',\n      port: 2222,\n      credentials: {\n      username: 'root',\n      password: 'password',\n      },\n  },\n  });\n\n  // Get the remote index from your source\n  const remoteIndex = fetch('my/api/or/my/storage/rd-index.json');\n\n  // We generate a local index (you could get an existing one using .findLocalIndex)\n  const localIndex = await racDeltaClient.pipelines.download.loadLocalIndex('my/build');\n\n  // Generate delta plan for the download\n  const deltaPlan = await racDeltaClient.delta.compareForDownload(localIndex, remoteIndex);\n\n  // Using the download to disk strategy. Chunk sources are mini services that connect reconstruction service with a source of chunks\n  // (in this case, your own disk)\n  const diskChunkSource = await racDeltaClient.pipelines.download.downloadAllMissingChunks(\n  deltaPlan,\n  'disk',\n  {\n    chunksSavePath: 'my/temp',\n  }\n  );\n\n  // Then we reconstruct all files of the update and save the index\n  await racDeltaClient.reconstruction.reconstructAll(deltaPlan, 'my/build', diskChunkSource);\n\n  await racDeltaClient.pipelines.download.saveLocalIndex('my/build', remoteIndex);\n\n"})]}),(0,s.jsxs)(l.A,{value:"rust",label:"Rust",children:[(0,s.jsx)("h4",{children:"Example usage of pipeline helpers:"}),(0,s.jsx)(a.A,{className:"language-rust",children:'\n  let config = RacDeltaConfig {\n      chunk_size: 1024 * 1024,\n      max_concurrency: Some(6),\n      storage: StorageConfig::SSH(SSHStorageConfig {\n          base: BaseStorageConfig {\n              path_prefix: Some("/root/upload".to_string()),\n          },\n          host: "localhost".to_string(),\n          port: Some(2222),\n          credentials: SSHCredentials {\n              username: "root".to_string(),\n              password: Some("password".to_string()),\n              private_key: None,\n          },\n      }),\n  };\n\n  let client: RacDeltaClient = RacDeltaClient::new(config).await?;\n\n  let remote_index = fetch from remote...;\n\n  // Generate local rd-index.json (you could use client.delta.create_index_from_directory too)\n  let local_index: Option<RDIndex> = match client.pipelines.download {\n      DownloadPipelineBundle::Hash(ref pipeline) => {\n          Some(pipeline.load_local_index(Path::new("my/dir")).await?)\n      }\n      DownloadPipelineBundle::Url(ref _p) => None,\n  };\n\n  // Generate a DeltaPlan comparing both indexes\n  let delta_plan: DeltaPlan = client\n      .delta\n      .compare_for_download(Some(&local_index.unwrap()), remote_index)\n      .await?;\n\n  // Using the download to disk strategy. Chunk sources are mini services that connect reconstruction service with a source of chunks\n  // (in this case, your own disk)\n  let chunk_source: Option<Arc<dyn ChunkSource>> = match client.pipelines.download {\n      DownloadPipelineBundle::Hash(ref pipeline) => Some(\n          pipeline\n              .download_all_missing_chunks(\n                  &delta_plan,\n                  DownloadTarget::Disk,\n                  Some(DownloadOptions {\n                      chunks_save_path: Some(Path::new("my/temp").to_path_buf()),\n                      ..Default::default()\n                  }),\n              )\n              .await?,\n      ),\n      DownloadPipelineBundle::Url(ref _p) => None,\n  };\n\n  client.reconstruction.reconstruct_all(\n      &delta_plan,\n      Path::new("my/dir"),\n      chunk_source.unwrap(),\n      None,\n  );\n\n  match client.pipelines.download {\n      DownloadPipelineBundle::Hash(ref pipeline) => {\n          pipeline\n              .save_local_index(Path::new("my/dir"), &local_index.unwrap())\n              .await?\n      }\n\n      DownloadPipelineBundle::Url(ref _p) => (),\n  };\n  '}),(0,s.jsx)(n.p,{children:"For Rust, pipelines are always divided in Hash and Url, this is made because UrlPipeline execute differs from HashPipeline, making an Enum resolves this partially, but the project is open for enhancements!"}),(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note"}),": For almost every case you will use Hash pipeline, Url is only for the URL storage type."]})]})]}),"\n",(0,s.jsxs)(n.p,{children:["For a full list of Download Pipeline helpers see: ",(0,s.jsx)(n.a,{href:"/core/pipelines",children:"pipelines"}),"\nAlso see ",(0,s.jsx)(n.a,{href:"/core/interfaces#DeltaPlan",children:"DeltaPlan"})]})]})}function x(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}},9365:(e,n,t)=>{t.d(n,{A:()=>i});t(6540);var r=t(4164);const s={tabItem:"tabItem_Ymn6"};var o=t(4848);function i({children:e,hidden:n,className:t}){return(0,o.jsx)("div",{role:"tabpanel",className:(0,r.A)(s.tabItem,t),hidden:n,children:e})}}}]);