"use strict";(globalThis.webpackChunkrac_delta_docs=globalThis.webpackChunkrac_delta_docs||[]).push([[1790],{1470:(e,n,t)=>{t.d(n,{A:()=>_});var r=t(6540),l=t(4164),s=t(7559),a=t(3104),i=t(6347),o=t(205),d=t(7485),c=t(1682),h=t(679);function u(e){return r.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}function p(e){const{values:n,children:t}=e;return(0,r.useMemo)(()=>{const e=n??function(e){return u(e).map(({props:{value:e,label:n,attributes:t,default:r}})=>({value:e,label:n,attributes:t,default:r}))}(t);return function(e){const n=(0,c.XI)(e,(e,n)=>e.value===n.value);if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map(e=>e.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e},[n,t])}function x({value:e,tabValues:n}){return n.some(n=>n.value===e)}function j({queryString:e=!1,groupId:n}){const t=(0,i.W6)(),l=function({queryString:e=!1,groupId:n}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,d.aZ)(l),(0,r.useCallback)(e=>{if(!l)return;const n=new URLSearchParams(t.location.search);n.set(l,e),t.replace({...t.location,search:n.toString()})},[l,t])]}function g(e){const{defaultValue:n,queryString:t=!1,groupId:l}=e,s=p(e),[a,i]=(0,r.useState)(()=>function({defaultValue:e,tabValues:n}){if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!x({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map(e=>e.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const t=n.find(e=>e.default)??n[0];if(!t)throw new Error("Unexpected error: 0 tabValues");return t.value}({defaultValue:n,tabValues:s})),[d,c]=j({queryString:t,groupId:l}),[u,g]=function({groupId:e}){const n=function(e){return e?`docusaurus.tab.${e}`:null}(e),[t,l]=(0,h.Dv)(n);return[t,(0,r.useCallback)(e=>{n&&l.set(e)},[n,l])]}({groupId:l}),m=(()=>{const e=d??u;return x({value:e,tabValues:s})?e:null})();(0,o.A)(()=>{m&&i(m)},[m]);return{selectedValue:a,selectValue:(0,r.useCallback)(e=>{if(!x({value:e,tabValues:s}))throw new Error(`Can't select invalid tab value=${e}`);i(e),c(e),g(e)},[c,g,s]),tabValues:s}}var m=t(2303);const f={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var b=t(4848);function y({className:e,block:n,selectedValue:t,selectValue:r,tabValues:s}){const i=[],{blockElementScrollPositionUntilNextRender:o}=(0,a.a_)(),d=e=>{const n=e.currentTarget,l=i.indexOf(n),a=s[l].value;a!==t&&(o(n),r(a))},c=e=>{let n=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const t=i.indexOf(e.currentTarget)+1;n=i[t]??i[0];break}case"ArrowLeft":{const t=i.indexOf(e.currentTarget)-1;n=i[t]??i[i.length-1];break}}n?.focus()};return(0,b.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,l.A)("tabs",{"tabs--block":n},e),children:s.map(({value:e,label:n,attributes:r})=>(0,b.jsx)("li",{role:"tab",tabIndex:t===e?0:-1,"aria-selected":t===e,ref:e=>{i.push(e)},onKeyDown:c,onClick:d,...r,className:(0,l.A)("tabs__item",f.tabItem,r?.className,{"tabs__item--active":t===e}),children:n??e},e))})}function w({lazy:e,children:n,selectedValue:t}){const s=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const e=s.find(e=>e.props.value===t);return e?(0,r.cloneElement)(e,{className:(0,l.A)("margin-top--md",e.props.className)}):null}return(0,b.jsx)("div",{className:"margin-top--md",children:s.map((e,n)=>(0,r.cloneElement)(e,{key:n,hidden:e.props.value!==t}))})}function v(e){const n=g(e);return(0,b.jsxs)("div",{className:(0,l.A)(s.G.tabs.container,"tabs-container",f.tabList),children:[(0,b.jsx)(y,{...n,...e}),(0,b.jsx)(w,{...n,...e})]})}function _(e){const n=(0,m.A)();return(0,b.jsx)(v,{...e,children:u(e.children)},String(n))}},4921:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>h,contentTitle:()=>c,default:()=>x,frontMatter:()=>d,metadata:()=>r,toc:()=>u});const r=JSON.parse('{"id":"usage/uploading","title":"Uploading","description":"One of the main operations for rac-delta is uploading new versions of your builds or directories, and apply only chunk changed or removing obsolete chunks from remote storage.","source":"@site/docs/usage/uploading.mdx","sourceDirName":"usage","slug":"/usage/uploading","permalink":"/rac-delta-docs/usage/uploading","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Client","permalink":"/rac-delta-docs/usage/client"},"next":{"title":"Downloading","permalink":"/rac-delta-docs/usage/downloading"}}');var l=t(4848),s=t(8453),a=t(1470),i=t(9365),o=t(3457);const d={sidebar_position:2},c="Uploading",h={},u=[{value:"Upload pipeline",id:"upload-pipeline",level:2},{value:"Pipeline helpers",id:"pipeline-helpers",level:2}];function p(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,s.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.header,{children:(0,l.jsx)(n.h1,{id:"uploading",children:"Uploading"})}),"\n",(0,l.jsx)(n.p,{children:"One of the main operations for rac-delta is uploading new versions of your builds or directories, and apply only chunk changed or removing obsolete chunks from remote storage."}),"\n",(0,l.jsx)(n.p,{children:"You can use rac-delta to update a build or to upload a completely new build to your storage."}),"\n",(0,l.jsx)(n.h2,{id:"upload-pipeline",children:"Upload pipeline"}),"\n",(0,l.jsx)(n.p,{children:"For this, rac-delta SDK provides an upload pipeline which already implements all steps to automatically upload new builds to your storage."}),"\n",(0,l.jsxs)(a.A,{children:[(0,l.jsxs)(i.A,{value:"node",label:"Node.js",children:[(0,l.jsx)("h4",{children:"Basic pipeline usage:"}),(0,l.jsx)(o.A,{className:"language-ts",children:"\n  const remoteIndexToUse = undefined;\n\n  await racDeltaClient.pipelines.upload.execute('path/to/build', remoteIndexToUse, {\n      requireRemoteIndex: false,\n      force: false,\n      ignorePatterns: undefined,\n      onStateChange: (state) => {\n          console.log(state);\n      },\n      onProgress: (type, progress, speed) => {\n          console.log(type, progress.toFixed(1), speed?.toFixed(1));\n      },\n  });\n  "}),(0,l.jsx)("h4",{children:"Parameters:"}),(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"Name"}),(0,l.jsx)(n.th,{children:"Type"}),(0,l.jsx)(n.th,{children:"Description"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"path"}),(0,l.jsx)(n.td,{children:(0,l.jsx)(n.code,{children:"string"})}),(0,l.jsx)(n.td,{children:"The path to your local build that will be uploaded (relative or absolute path)"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"remote rd-index"}),(0,l.jsx)(n.td,{children:(0,l.jsx)(n.code,{children:"RDIndex"})}),(0,l.jsx)(n.td,{children:"The rd-index.json as RDIndex object that will be used as remote index, if none provided, the pipeline will try to download it from your storage"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"upload options"}),(0,l.jsx)(n.td,{children:(0,l.jsx)(n.code,{children:"UploadOptions"})}),(0,l.jsx)(n.td,{children:(0,l.jsxs)("table",{children:[" ",(0,l.jsxs)("thead",{children:[" ",(0,l.jsxs)("tr",{children:[" ",(0,l.jsx)("th",{children:"Parameter"})," ",(0,l.jsx)("th",{children:"Type"})," ",(0,l.jsx)("th",{children:"Description"})," "]})," "]})," ",(0,l.jsxs)("tbody",{children:[" ",(0,l.jsxs)("tr",{children:[" ",(0,l.jsx)("td",{children:"requireRemoteIndex"})," ",(0,l.jsx)("td",{children:(0,l.jsx)("code",{children:"boolean"})})," ",(0,l.jsx)("td",{children:"If false, won't throw error if no remote index found and will upload everything"})," "]})," ",(0,l.jsxs)("tr",{children:[" ",(0,l.jsx)("td",{children:"force"})," ",(0,l.jsx)("td",{children:(0,l.jsx)("code",{children:"boolean"})})," ",(0,l.jsx)("td",{children:"If true, will upload everything except ignore patterns"})," "]})," ",(0,l.jsxs)("tr",{children:[" ",(0,l.jsx)("td",{children:"ignorePatterns"})," ",(0,l.jsx)("td",{children:(0,l.jsx)("code",{children:"string[]"})})," ",(0,l.jsx)("td",{children:"files or directories to ignore at the generation of the rd-index.json. Example: '*.zip' or 'dir/**'"})," "]})," ",(0,l.jsxs)("tr",{children:[" ",(0,l.jsx)("td",{children:"onStateChange"}),(0,l.jsx)("td",{children:(0,l.jsx)("code",{children:"(state: UploadState) => void"})})," ",(0,l.jsxs)("td",{children:["Callback that will notify when the pipeline changes its state. Available states are: ",(0,l.jsx)(n.strong,{children:"uploading"}),", ",(0,l.jsx)(n.strong,{children:"comparing"}),", ",(0,l.jsx)(n.strong,{children:"cleaning"}),", ",(0,l.jsx)(n.strong,{children:"scanning"})," and ",(0,l.jsx)(n.strong,{children:"finalizing"})]})," "]})," ",(0,l.jsxs)("tr",{children:[(0,l.jsx)("td",{children:"onProgress"}),(0,l.jsx)("td",{children:(0,l.jsx)("code",{children:'(type: "upload" | "deleting", progress: number, speed?: number'})}),(0,l.jsx)("td",{children:"Callback that will notify the progress of the upload operations. It will notify uploading progress and network speed, and deleting remote chunks progress"})]})," "]})," "]})})]})]})]})]}),(0,l.jsxs)(i.A,{value:"rust",label:"Rust",children:[(0,l.jsx)("h4",{children:"Basic pipeline usage:"}),(0,l.jsx)(o.A,{className:"language-rust",children:'\n  let remote_index_to_use: Option<RDIndex> = None;\n\n  match client.pipelines.upload {\n      UploadPipelineBundle::Hash(pipeline) => {\n          pipeline\n              .execute(\n                  Path::new("my/dir"),\n                  remote_index_to_use,\n                  Some(UploadOptions {\n                      require_remote_index: Some(false),\n                      force: Some(false),\n                      ignore_patterns: None,\n                      on_state_change: Some(std::sync::Arc::new(|state| {\n                          println!("Upload state: {:?}", state);\n                      })),\n                      on_progress: Some(std::sync::Arc::new(|phase, progress, speed| {\n                          println!(\n                              "Phase: {:?}, progress: {:.1}%, speed: {}",\n                              phase,\n                              progress * 100.0,\n                              speed\n                                  .map_or("unknown".to_string(), |s| format!("{:.1} bytes/s", s))\n                          );\n                      })),\n                  }),\n              )\n              .await?;\n      }\n      UploadPipelineBundle::Url(_p) => {\n          // none for SSH\n      }\n  }\n  '}),(0,l.jsx)("h4",{children:"Parameters:"}),(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"Name"}),(0,l.jsx)(n.th,{children:"Type"}),(0,l.jsx)(n.th,{children:"Description"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"path"}),(0,l.jsx)(n.td,{children:(0,l.jsx)(n.code,{children:"Path"})}),(0,l.jsx)(n.td,{children:"The path to your local build that will be uploaded (relative or absolute path)"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"remote rd-index"}),(0,l.jsx)(n.td,{children:(0,l.jsx)(n.code,{children:"Option<RDIndex>"})}),(0,l.jsx)(n.td,{children:"The rd-index.json as RDIndex object that will be used as remote index, if none provided, the pipeline will try to download it from your storage"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"upload options"}),(0,l.jsx)(n.td,{children:(0,l.jsx)(n.code,{children:"Option<UploadOptions>"})}),(0,l.jsx)(n.td,{children:(0,l.jsxs)("table",{children:[" ",(0,l.jsxs)("thead",{children:[" ",(0,l.jsxs)("tr",{children:[" ",(0,l.jsx)("th",{children:"Parameter"})," ",(0,l.jsx)("th",{children:"Type"})," ",(0,l.jsx)("th",{children:"Description"})," "]})," "]})," ",(0,l.jsxs)("tbody",{children:[" ",(0,l.jsxs)("tr",{children:[" ",(0,l.jsx)("td",{children:"require_remote_index"})," ",(0,l.jsx)("td",{children:(0,l.jsx)("code",{children:"Option<bool>"})})," ",(0,l.jsx)("td",{children:"If false, won't throw error if no remote index found and will upload everything"})," "]})," ",(0,l.jsxs)("tr",{children:[" ",(0,l.jsx)("td",{children:"force"})," ",(0,l.jsx)("td",{children:(0,l.jsx)("code",{children:"Option<bool>"})})," ",(0,l.jsx)("td",{children:"If true, will upload everything except ignore patterns"})," "]})," ",(0,l.jsxs)("tr",{children:[" ",(0,l.jsx)("td",{children:"ignore_patterns"})," ",(0,l.jsx)("td",{children:(0,l.jsx)("code",{children:"Option<Vec<String, Global>>"})})," ",(0,l.jsx)("td",{children:"files or directories to ignore at the generation of the rd-index.json. Example: '*.zip' or 'dir/**'"})," "]})," ",(0,l.jsxs)("tr",{children:[" ",(0,l.jsx)("td",{children:"on_state_change"}),(0,l.jsx)("td",{children:(0,l.jsx)("code",{children:"Option<Arc<dyn Fn(UploadState) + Send + Sync + 'static, Global>>"})})," ",(0,l.jsxs)("td",{children:["Callback that will notify when the pipeline changes its state. Available states are: ",(0,l.jsx)(n.strong,{children:"uploading"}),", ",(0,l.jsx)(n.strong,{children:"comparing"}),", ",(0,l.jsx)(n.strong,{children:"cleaning"}),", ",(0,l.jsx)(n.strong,{children:"scanning"})," and ",(0,l.jsx)(n.strong,{children:"finalizing"})]})," "]})," ",(0,l.jsxs)("tr",{children:[(0,l.jsx)("td",{children:"on_progress"}),(0,l.jsx)("td",{children:(0,l.jsx)("code",{children:"Option<Arc<dyn Fn(UploadPhase, f64, Option<f64>) + Send + Sync + 'static, Global>>"})}),(0,l.jsx)("td",{children:"Callback that will notify the progress of the upload operations. It will notify uploading progress and network speed, and deleting remote chunks progress"})]})," "]})," "]})})]})]})]})]})]}),"\n",(0,l.jsx)(n.p,{children:"This will automatically generate your local rd-index.json, get remote rd-index.json if none was provided, compare both indexes, generate a Delta Plan and upload and cleaning the new chunks to your storage configured in the rac-delta client."}),"\n",(0,l.jsx)(n.h2,{id:"pipeline-helpers",children:"Pipeline helpers"}),"\n",(0,l.jsx)(n.p,{children:"In order to achieve the correct upload of the directory using rac-delta, the upload pipeline uses internal methods that uses rac-delta services for uploading, index comparison, deletion of obsolete chunks, etc..."}),"\n",(0,l.jsx)(n.p,{children:"If you don't want to use the default execute method, you can create your own pipeline using those helpers and services."}),"\n",(0,l.jsxs)(a.A,{children:[(0,l.jsxs)(i.A,{value:"node",label:"Node.js",children:[(0,l.jsx)("h4",{children:"Example usage of pipeline helpers:"}),(0,l.jsx)(o.A,{className:"language-ts",children:"\n  const racDeltaClient = new RacDeltaClient({\n  chunkSize: 1024 * 1024,\n  maxConcurrency: 6,\n  storage: {\n      type: 'ssh',\n      host: 'localhost',\n      pathPrefix: '/root/upload',\n      port: 2222,\n      credentials: {\n      username: 'root',\n      password: 'password',\n      },\n  },\n  });\n\n  const remoteIndex = fetch('my/api/or/my/storage/rd-index.json');\n\n  // Generate local rd-index.json (you could use racDeltaClient.delta.createIndexFromDirectory too)\n  const localIndex = await racDeltaClient.pipelines.upload.scanDirectory('my/build');\n\n  // Generate a deltaPlan comparing both indexes\n  const deltaPlan = await racDeltaClient.delta.compareForUpload(localIndex, remoteIndex);\n\n  // Upload new chunks (uses maxConcurrency from client)\n  await racDeltaClient.pipelines.upload.uploadMissingChunks(deltaPlan, 'my/build', false);\n\n  //... Delete obsolete chunks, upload new rd-index... etc\n\n"})]}),(0,l.jsxs)(i.A,{value:"rust",label:"Rust",children:[(0,l.jsx)("h4",{children:"Example usage of pipeline helpers:"}),(0,l.jsx)(o.A,{className:"language-rust",children:'\n  let config = RacDeltaConfig {\n      chunk_size: 1024 * 1024,\n      max_concurrency: Some(6),\n      storage: StorageConfig::SSH(SSHStorageConfig {\n          base: BaseStorageConfig {\n              path_prefix: Some("/root/upload".to_string()),\n          },\n          host: "localhost".to_string(),\n          port: Some(2222),\n          credentials: SSHCredentials {\n              username: "root".to_string(),\n              password: Some("password".to_string()),\n              private_key: None,\n          },\n      }),\n  };\n\n  let client: RacDeltaClient = RacDeltaClient::new(config).await?;\n\n  let remote_index = fetch from remote...;\n\n  // Generate local rd-index.json (you could use client.delta.create_index_from_directory too)\n  let local_index: Option<RDIndex> = match client.pipelines.upload {\n      UploadPipelineBundle::Hash(ref pipeline) => {\n          Some(pipeline.scan_directory(Path::new("my/dir"), None).await?)\n      }\n      UploadPipelineBundle::Url(ref _p) => None,\n  };\n\n  // Generate a DeltaPlan comparing both indexes\n  let delta_plan: DeltaPlan = client\n      .delta\n      .compare_for_upload(&local_index.unwrap(), remote_index)\n      .await?;\n\n  // Upload new chunks (uses max_concurrency from client)\n  match client.pipelines.upload {\n      UploadPipelineBundle::Hash(ref pipeline) => {\n          pipeline\n              .upload_missing_chunks(&delta_plan, Path::new("my/dir"), false, None)\n              .await?\n      }\n      UploadPipelineBundle::Url(ref _p) => (),\n  };\n\n  //... Delete obsolete chunks, upload new rd-index... etc\n  '}),(0,l.jsx)(n.p,{children:"For Rust, pipelines are always divided in Hash and Url, this is made because UrlPipeline execute differs from HashPipeline, making an Enum resolves this partially, but the project is open for enhancements!"}),(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Note"}),": For almost every case you will use Hash pipeline, Url is only for the URL storage type."]})]})]}),"\n",(0,l.jsxs)(n.p,{children:["For a full list of Upload Pipeline helpers see: ",(0,l.jsx)(n.a,{href:"/core/pipelines",children:"pipelines"}),"\nAlso see ",(0,l.jsx)(n.a,{href:"/core/interfaces#DeltaPlan",children:"DeltaPlan"})]})]})}function x(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(p,{...e})}):p(e)}},9365:(e,n,t)=>{t.d(n,{A:()=>a});t(6540);var r=t(4164);const l={tabItem:"tabItem_Ymn6"};var s=t(4848);function a({children:e,hidden:n,className:t}){return(0,s.jsx)("div",{role:"tabpanel",className:(0,r.A)(l.tabItem,t),hidden:n,children:e})}}}]);