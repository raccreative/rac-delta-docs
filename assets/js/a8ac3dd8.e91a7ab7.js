"use strict";(globalThis.webpackChunkrac_delta_docs=globalThis.webpackChunkrac_delta_docs||[]).push([[5917],{1470:(e,n,t)=>{t.d(n,{A:()=>j});var r=t(6540),a=t(4164),s=t(7559),i=t(3104),o=t(6347),l=t(205),c=t(7485),u=t(1682),d=t(679);function h(e){return r.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}function f(e){const{values:n,children:t}=e;return(0,r.useMemo)(()=>{const e=n??function(e){return h(e).map(({props:{value:e,label:n,attributes:t,default:r}})=>({value:e,label:n,attributes:t,default:r}))}(t);return function(e){const n=(0,u.XI)(e,(e,n)=>e.value===n.value);if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map(e=>e.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e},[n,t])}function m({value:e,tabValues:n}){return n.some(n=>n.value===e)}function p({queryString:e=!1,groupId:n}){const t=(0,o.W6)(),a=function({queryString:e=!1,groupId:n}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,c.aZ)(a),(0,r.useCallback)(e=>{if(!a)return;const n=new URLSearchParams(t.location.search);n.set(a,e),t.replace({...t.location,search:n.toString()})},[a,t])]}function g(e){const{defaultValue:n,queryString:t=!1,groupId:a}=e,s=f(e),[i,o]=(0,r.useState)(()=>function({defaultValue:e,tabValues:n}){if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!m({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map(e=>e.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const t=n.find(e=>e.default)??n[0];if(!t)throw new Error("Unexpected error: 0 tabValues");return t.value}({defaultValue:n,tabValues:s})),[c,u]=p({queryString:t,groupId:a}),[h,g]=function({groupId:e}){const n=function(e){return e?`docusaurus.tab.${e}`:null}(e),[t,a]=(0,d.Dv)(n);return[t,(0,r.useCallback)(e=>{n&&a.set(e)},[n,a])]}({groupId:a}),x=(()=>{const e=c??h;return m({value:e,tabValues:s})?e:null})();(0,l.A)(()=>{x&&o(x)},[x]);return{selectedValue:i,selectValue:(0,r.useCallback)(e=>{if(!m({value:e,tabValues:s}))throw new Error(`Can't select invalid tab value=${e}`);o(e),u(e),g(e)},[u,g,s]),tabValues:s}}var x=t(2303);const v={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var b=t(4848);function y({className:e,block:n,selectedValue:t,selectValue:r,tabValues:s}){const o=[],{blockElementScrollPositionUntilNextRender:l}=(0,i.a_)(),c=e=>{const n=e.currentTarget,a=o.indexOf(n),i=s[a].value;i!==t&&(l(n),r(i))},u=e=>{let n=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const t=o.indexOf(e.currentTarget)+1;n=o[t]??o[0];break}case"ArrowLeft":{const t=o.indexOf(e.currentTarget)-1;n=o[t]??o[o.length-1];break}}n?.focus()};return(0,b.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,a.A)("tabs",{"tabs--block":n},e),children:s.map(({value:e,label:n,attributes:r})=>(0,b.jsx)("li",{role:"tab",tabIndex:t===e?0:-1,"aria-selected":t===e,ref:e=>{o.push(e)},onKeyDown:u,onClick:c,...r,className:(0,a.A)("tabs__item",v.tabItem,r?.className,{"tabs__item--active":t===e}),children:n??e},e))})}function S({lazy:e,children:n,selectedValue:t}){const s=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const e=s.find(e=>e.props.value===t);return e?(0,r.cloneElement)(e,{className:(0,a.A)("margin-top--md",e.props.className)}):null}return(0,b.jsx)("div",{className:"margin-top--md",children:s.map((e,n)=>(0,r.cloneElement)(e,{key:n,hidden:e.props.value!==t}))})}function w(e){const n=g(e);return(0,b.jsxs)("div",{className:(0,a.A)(s.G.tabs.container,"tabs-container",v.tabList),children:[(0,b.jsx)(y,{...n,...e}),(0,b.jsx)(S,{...n,...e})]})}function j(e){const n=(0,x.A)();return(0,b.jsx)(w,{...e,children:h(e.children)},String(n))}},7165:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>u,default:()=>m,frontMatter:()=>c,metadata:()=>r,toc:()=>h});const r=JSON.parse('{"id":"usage/services","title":"Services","description":"The rac-delta SDK has 4 services that will be responsible of all operations in the pipelines, and can be used individually for custom operations or customization of pipelines.","source":"@site/docs/usage/services.mdx","sourceDirName":"usage","slug":"/usage/services","permalink":"/rac-delta-docs/usage/services","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Downloading","permalink":"/rac-delta-docs/usage/downloading"},"next":{"title":"Storage adapter","permalink":"/rac-delta-docs/usage/storage-adapter"}}');var a=t(4848),s=t(8453),i=t(1470),o=t(9365),l=t(3457);const c={sidebar_position:4},u="Services",d={},h=[{value:"Hasher service",id:"hasher-service",level:2},{value:"Validation service",id:"validation-service",level:2},{value:"Delta service",id:"delta-service",level:2},{value:"Streaming",id:"streaming",level:3},{value:"Reconstruction service",id:"reconstruction-service",level:2},{value:"Streaming",id:"streaming-1",level:3}];function f(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",strong:"strong",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"services",children:"Services"})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.strong,{children:"rac-delta"})," SDK has 4 services that will be responsible of all operations in the pipelines, and can be used individually for custom operations or customization of pipelines."]}),"\n",(0,a.jsx)(n.h2,{id:"hasher-service",children:"Hasher service"}),"\n",(0,a.jsxs)(n.p,{children:["The hasher service is responsible of implementing hashing to create file and chunk hashes, to verify integrity and to generate ",(0,a.jsx)(n.code,{children:"FileEntry"})," and ",(0,a.jsx)(n.code,{children:"Chunk"})," objects with its hashes."]}),"\n",(0,a.jsxs)(n.p,{children:["Our ",(0,a.jsx)(n.strong,{children:"NodeJS"})," version uses HashWasm with blake3 for this, and the ",(0,a.jsx)(n.strong,{children:"Rust"})," version uses blake3 crate."]}),"\n",(0,a.jsxs)(n.p,{children:["It has stream support using ",(0,a.jsx)(n.code,{children:"streamHash"})," method, that will generate a ",(0,a.jsx)(n.code,{children:"Chunk"})," object. You can use it to generate the chunks array of a file, but ",(0,a.jsx)(n.code,{children:"delta service"})," already implements a method for stream that uses this."]}),"\n",(0,a.jsxs)(i.A,{children:[(0,a.jsxs)(o.A,{value:"node",label:"Node.js",children:[(0,a.jsx)("h4",{children:"Example usage of hasher service:"}),(0,a.jsx)(l.A,{className:"language-ts",children:"\n  // We hash a file and returns a fileEntry, that contains meta data and a list of its chunks (and chunk hashes)\n  const fileEntry = await racDeltaClient.hasher.hashFile('my-dir/file.txt', 'my-dir', 1024 * 1024);\n  "})]}),(0,a.jsxs)(o.A,{value:"rust",label:"Rust",children:[(0,a.jsx)("h4",{children:"Example usage of hasher service:"}),(0,a.jsx)(l.A,{className:"language-rust",children:'\n  // We hash a file and returns a fileEntry, that contains meta data and a list of its chunks (and chunk hashes)\n  let file_entry = client.hasher.hash_file("dir/file.txt", "dir", 1024 * 1024).await?;\n  '})]})]}),"\n",(0,a.jsx)(n.h2,{id:"validation-service",children:"Validation service"}),"\n",(0,a.jsxs)(n.p,{children:["The validation service is used only for validation of files and rd-index.json files. It uses the ",(0,a.jsx)(n.code,{children:"hasher service"})," for this, has basic methods that returns boolean."]}),"\n",(0,a.jsxs)(i.A,{children:[(0,a.jsxs)(o.A,{value:"node",label:"Node.js",children:[(0,a.jsx)("h4",{children:"Example usage of validation service:"}),(0,a.jsx)(l.A,{className:"language-ts",children:"\n  // We generate a FileEntry or we can get it from our rd-index.json\n  const fileEntry = await racDeltaClient.hasher.hashFile('my-dir/file.txt', 'my-dir', 1024 * 1024);\n\n  // Validates the file entry hash with the actual file hash\n  const valid = await racDeltaClient.validation.validateFile(fileEntry, 'my-dir/file.txt');\n  "})]}),(0,a.jsxs)(o.A,{value:"rust",label:"Rust",children:[(0,a.jsx)("h4",{children:"Example usage of validation service:"}),(0,a.jsx)(l.A,{className:"language-rust",children:'\n  // We generate a FileEntry or we can get it from our rd-index.json\n  let file_entry = client.hasher.hash_file("dir/file.txt", "dir", 1024 * 1024).await?;\n\n  // Validates the file entry hash with the actual file hash\n  let valid = client.validation.validate_file(&file_entry, "dir/file.txt").await?;\n  '})]})]}),"\n",(0,a.jsx)(n.h2,{id:"delta-service",children:"Delta service"}),"\n",(0,a.jsx)(n.p,{children:"The delta service is responsible of mainly creating rd-indexes, comparing rd-indexes or merging rd-indexes."}),"\n",(0,a.jsx)(n.p,{children:"Comparing two rd-index files will generate a Delta Plan that will include the changes to upload or download."}),"\n",(0,a.jsxs)(i.A,{children:[(0,a.jsxs)(o.A,{value:"node",label:"Node.js",children:[(0,a.jsx)("h4",{children:"Example usage of delta service:"}),(0,a.jsx)(l.A,{className:"language-ts",children:"\n  // Generate a rd-index object from directory, (path, chunkSize, concurrency, ignore patterns)\n  const index = await racDeltaClient.delta.createIndexFromDirectory('my-dir', 1024 * 1024, 6, ['*.zip']);\n  "})]}),(0,a.jsxs)(o.A,{value:"rust",label:"Rust",children:[(0,a.jsx)("h4",{children:"Example usage of delta service:"}),(0,a.jsx)(l.A,{className:"language-rust",children:'\n  // Generate a rd-index object from directory, (path, chunkSize, concurrency, ignore patterns)\n  let index = client.delta.create_index_from_directory(Path::new("my-dir"), 1024 * 1024, Some(6), Some(vec![String::from("*.zip")])).await?;\n  '})]})]}),"\n",(0,a.jsx)(n.h3,{id:"streaming",children:"Streaming"}),"\n",(0,a.jsx)(n.p,{children:"Delta service offers a way to generate file entries via streaming, perfect for use cases where memory is low."}),"\n",(0,a.jsxs)(i.A,{children:[(0,a.jsxs)(o.A,{value:"node",label:"Node.js",children:[(0,a.jsx)("h4",{children:"Generating a rd-index via streaming:"}),(0,a.jsx)(l.A,{className:"language-ts",children:"\n  //\n  // Adapter: Readable \u2192 AsyncChunkStream\n  //\n  class ReadableChunkStream implements AsyncChunkStream {\n      private reader: AsyncIterable<Uint8Array>;\n\n      constructor(path: string, chunkSize: number) {\n          this.reader = createReadStream(path, {\n              highWaterMark: chunkSize,\n          });\n      }\n\n      async *[Symbol.asyncIterator]() {\n          for await (const chunk of this.reader) {\n              yield new Uint8Array(chunk);\n          }\n      }\n\n      async nextChunk(): Promise<Uint8Array | null> {\n          const iterator = this[Symbol.asyncIterator]();\n\n          const result = await iterator.next();\n\n          return result.done ? null : result.value;\n      }\n  }\n\n  const racDeltaClient = new RacDeltaClient({\n      chunkSize: 1024 * 1024,\n      maxConcurrency: 6,\n      storage: {\n          type: 'ssh',\n          host: 'localhost',\n          pathPrefix: '/root/upload',\n          port: 2222,\n          credentials: {\n              username: 'root',\n              password: 'password',\n          },\n      },\n  });\n\n  const files = await readdir('my-dir');\n  const entries: FileEntry[] = [];\n\n  for (const name of files) {\n      const full = join('my-dir', name);\n      const stats = await stat(full);\n\n      if (!stats.isFile()) {\n          continue;\n      }\n\n      const stream = new ReadableChunkStream(full, 1024 * 1024);\n\n      const entry = await racDeltaClient.delta.createFileEntryFromStream(stream, full);\n\n      entries.push(entry);\n  }\n\n  const rdIndex: RDIndex = {\n      version: 1,\n      createdAt: Date.now(),\n      chunkSize: 1024 * 1024,\n      files: entries,\n  };\n  "})]}),(0,a.jsxs)(o.A,{value:"rust",label:"Rust",children:[(0,a.jsx)("h4",{children:"Generating a rd-index via streaming:"}),(0,a.jsx)(l.A,{className:"language-rust",children:'\n  use async_trait::async_trait;\n  use tokio::fs::File;\n  use tokio::io::{AsyncReadExt, BufReader};\n  \n  pub struct ReadableChunkStream {\n    reader: BufReader<File>,\n    chunk_size: usize,\n  }\n  \n  impl ReadableChunkStream {\n    pub async fn new(path: &str, chunk_size: usize) -> std::io::Result<Self> {\n      let file = File::open(path).await?;\n      Ok(Self {\n        reader: BufReader::new(file),\n        chunk_size,\n      })\n    }\n  }\n  \n  #[async_trait]\n  impl AsyncChunkStream for ReadableChunkStream {\n    async fn next_chunk(&mut self) -> Option<Vec<u8>> {\n      let mut buffer = vec![0u8; self.chunk_size];\n      \n      match self.reader.read(&mut buffer).await {\n        Ok(0) => None, // EOF\n        Ok(n) => {\n          buffer.truncate(n);\n          Some(buffer)\n        }\n        Err(_) => None,\n      }\n    }\n  }\n  \n  pub async fn build_rdindex() -> Result<RDIndex, Box<dyn std::error::Error>> {\n    let config = RacDeltaConfig {\n      chunk_size: 1024 * 1024,\n      max_concurrency: Some(6),\n      storage: StorageConfig::SSH(SSHStorageConfig {\n        base: BaseStorageConfig {\n          path_prefix: Some("/root/upload".to_string()),\n        },\n        host: "localhost".to_string(),\n        port: Some(2222),\n        credentials: SSHCredentials {\n          username: "root".to_string(),\n          password: Some("password".to_string()),\n          private_key: None,\n        },\n      }),\n    };\n    \n    let client = RacDeltaClient::new(config).await?;\n    \n    let mut entries: Vec<FileEntry> = Vec::new();\n    \n    let dir = "my-dir";\n    let mut read_dir = tokio::fs::read_dir(dir).await?;\n    \n    while let Some(entry) = read_dir.next_entry().await? {\n      let path = entry.path();\n      \n      if !path.is_file() {\n        continue;\n      }\n      \n      let full_path_str = path.to_string_lossy().to_string();\n      \n      let mut stream = ReadableChunkStream::new(&full_path_str, 1024 * 1024).await?;\n      \n      let file_entry = client\n      .delta\n      .create_file_entry_from_stream(&mut stream, &full_path_str)\n      .await?;\n      \n      entries.push(file_entry);\n    }\n    \n    let rd_index = RDIndex {\n      version: 1,\n      created_at: chrono::Utc::now().timestamp_millis() as u64,\n      chunk_size: 1024 * 1024,\n      files: entries,\n    };\n    \n    Ok(rd_index)\n  }\n  '})]})]}),"\n",(0,a.jsx)(n.h2,{id:"reconstruction-service",children:"Reconstruction service"}),"\n",(0,a.jsx)(n.p,{children:"The reconstruction service is a complex service that is responsible of reconstruct files via chunks."}),"\n",(0,a.jsx)(n.p,{children:"It can reconstruct a single file or all files of a given delta plan."}),"\n",(0,a.jsxs)(n.p,{children:["For reconstruction, the service uses a ",(0,a.jsx)(n.code,{children:"ChunkSource"}),", a special Class that connects directly with your storage adapter, your memory, or your disk, depending on how you want your chunks managed."]}),"\n",(0,a.jsx)(n.p,{children:"It uses different reconstruction strategies, depending on file size or chunk source. You can specify a file size threshold for in-place reconstruction or temp reconstruction."}),"\n",(0,a.jsxs)(i.A,{children:[(0,a.jsxs)(o.A,{value:"node",label:"Node.js",children:[(0,a.jsx)("h4",{children:"Example usage of reconstruction service:"}),(0,a.jsx)(l.A,{className:"language-ts",children:"\n  const racDeltaClient = new RacDeltaClient({\n      chunkSize: 1024 * 1024,\n      maxConcurrency: 6,\n      storage: {\n          type: 'ssh',\n          host: 'localhost',\n          pathPrefix: '/root/upload',\n          port: 2222,\n          credentials: {\n              username: 'root',\n              password: 'password',\n          },\n      },\n  });\n\n  // Create a Chunk Source using our current storage (SSH in this case)\n  const chunkSource = new StorageChunkSource(racDeltaClient.storage);\n\n  // Chunk sources brings a lot of possibilities, like reconstructing half of the files via storage and the other half via disk\n  // But in this case we reconstruct all the files via storage\n  await racDeltaClient.reconstruction.reconstructFile(\n      remoteIndex.files[0],\n      'output-dir/file.txt',\n      chunkSource,\n      { inPlaceReconstructionThreshold: 0 }\n  );\n  "})]}),(0,a.jsxs)(o.A,{value:"rust",label:"Rust",children:[(0,a.jsx)("h4",{children:"Example usage of reconstruction service:"}),(0,a.jsx)(l.A,{className:"language-rust",children:'\n  let config = RacDeltaConfig {\n      chunk_size: 1024 * 1024,\n      max_concurrency: Some(6),\n      storage: StorageConfig::SSH(SSHStorageConfig {\n          base: BaseStorageConfig {\n              path_prefix: Some("/root/upload".to_string()),\n          },\n          host: "localhost".to_string(),\n          port: Some(2222),\n          credentials: SSHCredentials {\n              username: "root".to_string(),\n              password: Some("password".to_string()),\n              private_key: None,\n          },\n      }),\n  };\n\n  let client: RacDeltaClient = RacDeltaClient::new(config).await?;\n\n  let chunk_source: StorageChunkSource = StorageChunkSource::new(client.storage, None);\n\n  client\n      .reconstruction\n      .reconstruct_file(\n          remote_index.files[0],\n          Path::new("output-dir/file.txt"),\n          &chunk_source,\n          Some(&ReconstructionOptions {\n              in_place_reconstruction_threshold: Some(0),\n              ..Default::default()\n          }),\n          None,\n      )\n      .await?;\n  '})]})]}),"\n",(0,a.jsxs)(n.p,{children:["For more, see ",(0,a.jsx)(n.a,{href:"/core/services#reconstruction-service",children:"ReconstructionService"})]}),"\n",(0,a.jsx)(n.h3,{id:"streaming-1",children:"Streaming"}),"\n",(0,a.jsxs)(n.p,{children:["Reconstruction service also supports streaming reconstruction using the ",(0,a.jsx)(n.code,{children:"reconstructToStream"})," method."]}),"\n",(0,a.jsx)(n.p,{children:"This will return a stream perfect for reconstruct the file to another source, like upload to third party storage or for compression."}),"\n",(0,a.jsxs)(i.A,{children:[(0,a.jsxs)(o.A,{value:"node",label:"Node.js",children:[(0,a.jsx)("h4",{children:"Example usage of reconstruction stream:"}),(0,a.jsx)(l.A,{className:"language-ts",children:"\n  const racDeltaClient = new RacDeltaClient({\n  chunkSize: 1024 * 1024,\n  maxConcurrency: 6,\n  storage: {\n      type: 'ssh',\n      host: 'localhost',\n      pathPrefix: '/root/upload',\n      port: 2222,\n      credentials: {\n          username: 'root',\n          password: 'password',\n      },\n  },\n  });\n\n  // Create a Chunk Source using our current storage (SSH in this case)\n  const chunkSource = new StorageChunkSource(racDeltaClient.storage);\n\n  const stream = await racDeltaClient.reconstruction.reconstructToStream(\n      remoteIndex.files[0],\n      chunkSource\n  );\n\n  // Example stream upload to S3\n  await s3.send(\n      new PutObjectCommand({\n          Bucket: 'my-bucket',\n          Key: 'files/file.txt',\n          Body: stream,\n      })\n  );\n  "})]}),(0,a.jsxs)(o.A,{value:"rust",label:"Rust",children:[(0,a.jsx)("h4",{children:"Example usage of reconstruction stream:"}),(0,a.jsx)(l.A,{className:"language-rust",children:'\n  let config = RacDeltaConfig {\n      chunk_size: 1024 * 1024,\n      max_concurrency: Some(6),\n      storage: StorageConfig::SSH(SSHStorageConfig {\n          base: BaseStorageConfig {\n              path_prefix: Some("/root/upload".to_string()),\n          },\n          host: "localhost".to_string(),\n          port: Some(2222),\n          credentials: SSHCredentials {\n              username: "root".to_string(),\n              password: Some("password".to_string()),\n              private_key: None,\n          },\n      }),\n  };\n\n  let client: RacDeltaClient = RacDeltaClient::new(config).await?;\n\n  let chunk_source: StorageChunkSource = StorageChunkSource::new(client.storage, None);\n\n  let stream: Pin<Box<dyn AsyncRead + Send + Sync>> = client\n      .reconstruction\n      .reconstruct_to_stream(remote_index.files[0], Arc::new(chunk_source))\n      .await?;\n\n  let byte_stream = ByteStream::from_reader(stream);\n\n  s3_client\n      .put_object()\n      .bucket("my-bucket")\n      .key("files/file.txt")\n      .body(byte_stream)\n      .send()\n      .await?;\n  '})]})]})]})}function m(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(f,{...e})}):f(e)}},9365:(e,n,t)=>{t.d(n,{A:()=>i});t(6540);var r=t(4164);const a={tabItem:"tabItem_Ymn6"};var s=t(4848);function i({children:e,hidden:n,className:t}){return(0,s.jsx)("div",{role:"tabpanel",className:(0,r.A)(a.tabItem,t),hidden:n,children:e})}}}]);