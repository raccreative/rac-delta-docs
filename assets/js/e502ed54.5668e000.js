"use strict";(globalThis.webpackChunkrac_delta_docs=globalThis.webpackChunkrac_delta_docs||[]).push([[4511],{7614:(e,s,r)=>{r.r(s),r.d(s,{assets:()=>t,contentTitle:()=>c,default:()=>o,frontMatter:()=>i,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"reference/NodeJS/services/hasher-service","title":"HasherService","description":"Abstract service for hashing files, streams, and buffers.","source":"@site/docs/reference/NodeJS/services/hasher-service.md","sourceDirName":"reference/NodeJS/services","slug":"/reference/NodeJS/services/hasher-service","permalink":"/rac-delta-docs/reference/NodeJS/services/hasher-service","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"HasherService","description":"Abstract service for hashing files, streams, and buffers.","sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Services","permalink":"/rac-delta-docs/category/services"},"next":{"title":"ValidationService","permalink":"/rac-delta-docs/reference/NodeJS/services/validation-service"}}');var d=r(4848),h=r(8453);const i={title:"HasherService",description:"Abstract service for hashing files, streams, and buffers.",sidebar_position:1},c="HasherService",t={},l=[{value:"Methods",id:"methods",level:2},{value:"Method Details",id:"method-details",level:2},{value:"<code>hashFile(filePath, rootDir, chunkSize)</code>",id:"hashfilefilepath-rootdir-chunksize",level:3},{value:"<code>hashStream(stream, onChunk?)</code>",id:"hashstreamstream-onchunk",level:3},{value:"<code>hashBuffer(data)</code>",id:"hashbufferdata",level:3},{value:"<code>verifyChunk(data, expectedHash)</code>",id:"verifychunkdata-expectedhash",level:3},{value:"<code>verifyFile(path, expectedHash)</code>",id:"verifyfilepath-expectedhash",level:3},{value:"<code>createStreamingHasher()</code>",id:"createstreaminghasher",level:3},{value:"Example",id:"example",level:2},{value:"Related",id:"related",level:2}];function a(e){const s={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,h.R)(),...e.components};return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsx)(s.header,{children:(0,d.jsx)(s.h1,{id:"hasherservice",children:"HasherService"})}),"\n",(0,d.jsxs)(s.p,{children:[(0,d.jsx)(s.code,{children:"HasherService"})," defines the API to calculate hashes of files, chunks, streams, and buffers.\nIt is abstract; real implementations are in the infrastructure layer\n(e.g., ",(0,d.jsx)(s.code,{children:"HashWasmHasherService"})," in Node.js)."]}),"\n",(0,d.jsxs)(s.p,{children:["This page documents the ",(0,d.jsx)(s.strong,{children:"public API available in the Node.js SDK"}),"."]}),"\n",(0,d.jsx)(s.hr,{}),"\n",(0,d.jsx)(s.h2,{id:"methods",children:"Methods"}),"\n",(0,d.jsxs)(s.table,{children:[(0,d.jsx)(s.thead,{children:(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.th,{children:"Method"}),(0,d.jsx)(s.th,{children:"Returns"}),(0,d.jsx)(s.th,{children:"Description"})]})}),(0,d.jsxs)(s.tbody,{children:[(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"hashFile(filePath, rootDir, chunkSize)"})}),(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"Promise<FileEntry>"})}),(0,d.jsxs)(s.td,{children:["Returns a ",(0,d.jsx)(s.code,{children:"FileEntry"})," calculating the file hash and chunk hashes."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"hashStream(stream, onChunk?)"})}),(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"Promise<Chunk[]>"})}),(0,d.jsx)(s.td,{children:"Processes a stream of chunks and returns an array of hashed chunks."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"hashBuffer(data)"})}),(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"Promise<string>"})}),(0,d.jsx)(s.td,{children:"Returns the hash of a buffer (hex string)."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"verifyChunk(data, expectedHash)"})}),(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"Promise<boolean>"})}),(0,d.jsx)(s.td,{children:"Verifies that a chunk has the expected hash."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"verifyFile(path, expectedHash)"})}),(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"Promise<boolean>"})}),(0,d.jsx)(s.td,{children:"Verifies that a file has the expected hash."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"createStreamingHasher()"})}),(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"Promise<StreamingHasher>"})}),(0,d.jsxs)(s.td,{children:["Creates a ",(0,d.jsx)(s.code,{children:"StreamingHasher"})," object for incremental hashing."]})]})]})]}),"\n",(0,d.jsx)(s.hr,{}),"\n",(0,d.jsx)(s.h2,{id:"method-details",children:"Method Details"}),"\n",(0,d.jsx)(s.h3,{id:"hashfilefilepath-rootdir-chunksize",children:(0,d.jsx)(s.code,{children:"hashFile(filePath, rootDir, chunkSize)"})}),"\n",(0,d.jsxs)(s.p,{children:["Returns a ",(0,d.jsx)(s.code,{children:"FileEntry"})," of the given file, calculating its hash and chunk hashes."]}),"\n",(0,d.jsxs)(s.p,{children:[(0,d.jsx)(s.strong,{children:"IMPORTANT NOTE:"})," selected chunkSize must be the same in all operations of rac-delta"]}),"\n",(0,d.jsx)(s.p,{children:(0,d.jsx)(s.strong,{children:"Parameters:"})}),"\n",(0,d.jsxs)(s.table,{children:[(0,d.jsx)(s.thead,{children:(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.th,{children:"Name"}),(0,d.jsx)(s.th,{children:"Type"}),(0,d.jsx)(s.th,{children:"Description"})]})}),(0,d.jsxs)(s.tbody,{children:[(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"filePath"})}),(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"string"})}),(0,d.jsxs)(s.td,{children:["Relative path of the file (",(0,d.jsx)(s.code,{children:"dir/file.txt"}),")"]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"rootDir"})}),(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"string"})}),(0,d.jsxs)(s.td,{children:["Root directory of the index (",(0,d.jsx)(s.code,{children:"dir"}),")"]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"chunkSize"})}),(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"number"})}),(0,d.jsx)(s.td,{children:"Size in bytes of each chunk (recommended 1 MB)"})]})]})]}),"\n",(0,d.jsxs)(s.p,{children:[(0,d.jsx)(s.strong,{children:"Returns:"})," ",(0,d.jsx)(s.code,{children:"Promise<FileEntry>"})]}),"\n",(0,d.jsx)(s.hr,{}),"\n",(0,d.jsx)(s.h3,{id:"hashstreamstream-onchunk",children:(0,d.jsx)(s.code,{children:"hashStream(stream, onChunk?)"})}),"\n",(0,d.jsxs)(s.p,{children:["Processes a stream of chunks, optionally calling ",(0,d.jsx)(s.code,{children:"onChunk"})," for each processed chunk."]}),"\n",(0,d.jsx)(s.p,{children:(0,d.jsx)(s.strong,{children:"Parameters:"})}),"\n",(0,d.jsxs)(s.table,{children:[(0,d.jsx)(s.thead,{children:(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.th,{children:"Name"}),(0,d.jsx)(s.th,{children:"Type"}),(0,d.jsx)(s.th,{children:"Description"})]})}),(0,d.jsxs)(s.tbody,{children:[(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"stream"})}),(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"AsyncChunkStream"})}),(0,d.jsx)(s.td,{children:"The input chunk stream"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"onChunk"})}),(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"(chunk: Uint8Array) => void"})}),(0,d.jsx)(s.td,{children:"Optional callback for each hashed chunk"})]})]})]}),"\n",(0,d.jsx)(s.pre,{children:(0,d.jsx)(s.code,{className:"language-ts",children:"export interface AsyncChunkStream extends AsyncIterable<Uint8Array> {\n  nextChunk(): Promise<Uint8Array | null>;\n  reset?(): Promise<void>;\n  close?(): Promise<void>;\n}\n"})}),"\n",(0,d.jsxs)(s.p,{children:[(0,d.jsx)(s.strong,{children:"Returns:"})," ",(0,d.jsx)(s.code,{children:"Promise<Chunk[]>"})]}),"\n",(0,d.jsx)(s.hr,{}),"\n",(0,d.jsx)(s.h3,{id:"hashbufferdata",children:(0,d.jsx)(s.code,{children:"hashBuffer(data)"})}),"\n",(0,d.jsx)(s.p,{children:"Hashes a buffer."}),"\n",(0,d.jsxs)(s.table,{children:[(0,d.jsx)(s.thead,{children:(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.th,{children:"Parameter"}),(0,d.jsx)(s.th,{children:"Type"}),(0,d.jsx)(s.th,{children:"Description"})]})}),(0,d.jsx)(s.tbody,{children:(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"data"})}),(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"Uint8Array"})}),(0,d.jsx)(s.td,{children:"The buffer to hash"})]})})]}),"\n",(0,d.jsxs)(s.p,{children:[(0,d.jsx)(s.strong,{children:"Returns:"})," ",(0,d.jsx)(s.code,{children:"Promise<string>"})," (hex string)"]}),"\n",(0,d.jsx)(s.hr,{}),"\n",(0,d.jsx)(s.h3,{id:"verifychunkdata-expectedhash",children:(0,d.jsx)(s.code,{children:"verifyChunk(data, expectedHash)"})}),"\n",(0,d.jsx)(s.p,{children:"Checks if a chunk has the expected hash."}),"\n",(0,d.jsxs)(s.table,{children:[(0,d.jsx)(s.thead,{children:(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.th,{children:"Parameter"}),(0,d.jsx)(s.th,{children:"Type"}),(0,d.jsx)(s.th,{children:"Description"})]})}),(0,d.jsxs)(s.tbody,{children:[(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"data"})}),(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"Uint8Array"})}),(0,d.jsx)(s.td,{children:"Chunk data"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"expectedHash"})}),(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"string"})}),(0,d.jsx)(s.td,{children:"Expected hash"})]})]})]}),"\n",(0,d.jsxs)(s.p,{children:[(0,d.jsx)(s.strong,{children:"Returns:"})," ",(0,d.jsx)(s.code,{children:"Promise<boolean>"})]}),"\n",(0,d.jsx)(s.hr,{}),"\n",(0,d.jsx)(s.h3,{id:"verifyfilepath-expectedhash",children:(0,d.jsx)(s.code,{children:"verifyFile(path, expectedHash)"})}),"\n",(0,d.jsx)(s.p,{children:"Checks if a file has the expected hash."}),"\n",(0,d.jsxs)(s.table,{children:[(0,d.jsx)(s.thead,{children:(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.th,{children:"Parameter"}),(0,d.jsx)(s.th,{children:"Type"}),(0,d.jsx)(s.th,{children:"Description"})]})}),(0,d.jsxs)(s.tbody,{children:[(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"path"})}),(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"string"})}),(0,d.jsx)(s.td,{children:"File path"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"expectedHash"})}),(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"string"})}),(0,d.jsx)(s.td,{children:"Expected hash"})]})]})]}),"\n",(0,d.jsxs)(s.p,{children:[(0,d.jsx)(s.strong,{children:"Returns:"})," ",(0,d.jsx)(s.code,{children:"Promise<boolean>"})]}),"\n",(0,d.jsx)(s.hr,{}),"\n",(0,d.jsx)(s.h3,{id:"createstreaminghasher",children:(0,d.jsx)(s.code,{children:"createStreamingHasher()"})}),"\n",(0,d.jsxs)(s.p,{children:["Creates a ",(0,d.jsx)(s.code,{children:"StreamingHasher"})," instance:"]}),"\n",(0,d.jsx)(s.pre,{children:(0,d.jsx)(s.code,{className:"language-ts",children:"export interface StreamingHasher {\n  update(data: Uint8Array | Buffer): void;\n  digest(encoding?: 'hex'): string;\n}\n"})}),"\n",(0,d.jsxs)(s.p,{children:[(0,d.jsx)(s.strong,{children:"Returns:"})," ",(0,d.jsx)(s.code,{children:"Promise<StreamingHasher>"})]}),"\n",(0,d.jsx)(s.h2,{id:"example",children:"Example"}),"\n",(0,d.jsx)(s.pre,{children:(0,d.jsx)(s.code,{className:"language-ts",children:"const fileEntry = await racDeltaClient.hasher.hashFile('my-dir/file.txt', 'my-dir', 1024 * 1024);\n"})}),"\n",(0,d.jsx)(s.h2,{id:"related",children:"Related"}),"\n",(0,d.jsxs)(s.ul,{children:["\n",(0,d.jsx)(s.li,{children:(0,d.jsx)(s.a,{href:"/reference/NodeJS/models/rdindex",children:"RDIndex"})}),"\n",(0,d.jsx)(s.li,{children:(0,d.jsx)(s.a,{href:"/reference/NodeJS/models/file-entry",children:"FileEntry"})}),"\n",(0,d.jsx)(s.li,{children:(0,d.jsx)(s.a,{href:"/reference/NodeJS/models/chunk",children:"Chunk"})}),"\n"]})]})}function o(e={}){const{wrapper:s}={...(0,h.R)(),...e.components};return s?(0,d.jsx)(s,{...e,children:(0,d.jsx)(a,{...e})}):a(e)}},8453:(e,s,r)=>{r.d(s,{R:()=>i,x:()=>c});var n=r(6540);const d={},h=n.createContext(d);function i(e){const s=n.useContext(h);return n.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function c(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(d):e.components||d:i(e.components),n.createElement(h.Provider,{value:s},e.children)}}}]);