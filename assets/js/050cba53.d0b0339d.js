"use strict";(globalThis.webpackChunkrac_delta_docs=globalThis.webpackChunkrac_delta_docs||[]).push([[9810],{6072:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>d,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"core/storage-adapter","title":"Storage Adapter","description":"Storage Adapter is a special service that will implement the selected storage using the configuration seen on configuration. As rac-delta is storage agnostic, having an abstraction for storage is a perfect solution.","source":"@site/docs/core/storage-adapter.md","sourceDirName":"core","slug":"/core/storage-adapter","permalink":"/rac-delta-docs/core/storage-adapter","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Configuration","permalink":"/rac-delta-docs/core/configuration"},"next":{"title":"Services","permalink":"/rac-delta-docs/core/services"}}');var n=a(4848),s=a(8453);const o={sidebar_position:4},i="Storage Adapter",d={},l=[{value:"Base storage adapter",id:"base-storage-adapter",level:2},{value:"Hash storage adapter",id:"hash-storage-adapter",level:2},{value:"Url storage adapter",id:"url-storage-adapter",level:2}];function c(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"storage-adapter",children:"Storage Adapter"})}),"\n",(0,n.jsxs)(t.p,{children:["Storage Adapter is a special service that will implement the selected storage using the configuration seen on ",(0,n.jsx)(t.a,{href:"/core/configuration",children:"configuration"}),". As rac-delta is storage agnostic, having an abstraction for storage is a perfect solution."]}),"\n",(0,n.jsx)(t.p,{children:"Storage adapter will directly connect with your storage (Example: s3 sdk)."}),"\n",(0,n.jsx)(t.h2,{id:"base-storage-adapter",children:"Base storage adapter"}),"\n",(0,n.jsx)(t.p,{children:"As storage has two types (Url or Hash) needs a base class that will be extended. This is done because URL storage adapter needs different parameters and method names."}),"\n",(0,n.jsx)(t.p,{children:"(If you plan to implement only one type of storage, then you don't need to use the type division and only use the Storage Adapter you need)"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",children:"abstract class StorageAdapter {\n  abstract readonly type: 'hash' | 'url';\n\n  abstract dispose(): Promise<void>;\n}\n"})}),"\n",(0,n.jsx)(t.h2,{id:"hash-storage-adapter",children:"Hash storage adapter"}),"\n",(0,n.jsx)(t.p,{children:"This storage adapter type is made for every storage that works with hash paths (example: dir/chunks/hash). Every storage except URL storage uses this type."}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",metastring:'title="TypeScript abstraction example"',children:"abstract class HashStorageAdapter extends StorageAdapter {\n  readonly type = 'hash' as const;\n\n  abstract getChunk(hash: string): Promise<Readable | null>;\n\n  abstract putChunk(\n    hash: string,\n    data: Readable,\n    opts?: { overwrite?: boolean; size?: number }\n  ): Promise<void>;\n\n  abstract chunkExists(hash: string): Promise<boolean>;\n\n  abstract deleteChunk(hash: string): Promise<void>;\n\n  listChunks?(): Promise<string[]>;\n\n  getChunkInfo?(hash: string): Promise<BlobInfo | null>;\n\n  abstract getRemoteIndex(): Promise<RDIndex | null>;\n\n  abstract putRemoteIndex(index: RDIndex): Promise<void>;\n}\n\n// used for getChunkInfo\ninterface BlobInfo {\n  hash: string;\n  size: number;\n  modified?: Date;\n  metadata?: Record<string, string>;\n}\n"})}),"\n",(0,n.jsx)(t.h2,{id:"url-storage-adapter",children:"Url storage adapter"}),"\n",(0,n.jsx)(t.p,{children:"This adapter type is only used for the URL storage type:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",metastring:'title="TypeScript abstraction example"',children:"export abstract class UrlStorageAdapter extends StorageAdapter {\n  readonly type = 'url' as const;\n\n  abstract getChunkByUrl(url: string): Promise<Readable | null>;\n\n  abstract putChunkByUrl(url: string, data: Readable): Promise<void>;\n\n  abstract deleteChunkByUrl(url: string): Promise<void>;\n\n  abstract chunkExistsByUrl(url: string): Promise<boolean>;\n\n  listChunksByUrl?(url: string): Promise<string[]>;\n\n  getChunkInfoByUrl?(hash: string, url: string): Promise<BlobInfo | null>;\n\n  abstract getRemoteIndexByUrl(url: string): Promise<RDIndex | null>;\n\n  abstract putRemoteIndexByUrl(url: string, index: RDIndex): Promise<void>;\n}\n"})})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},8453:(e,t,a)=>{a.d(t,{R:()=>o,x:()=>i});var r=a(6540);const n={},s=r.createContext(n);function o(e){const t=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:o(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);