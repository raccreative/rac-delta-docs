"use strict";(globalThis.webpackChunkrac_delta_docs=globalThis.webpackChunkrac_delta_docs||[]).push([[6074],{3168:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>l,contentTitle:()=>d,default:()=>p,frontMatter:()=>i,metadata:()=>s,toc:()=>t});const s=JSON.parse('{"id":"core/pipelines","title":"Pipelines","description":"Pipelines son una forma opcional pero recomendada de unificar todos los servicios y configuraciones en una pipeline coherente que sigue el protocolo perfectamente.","source":"@site/i18n/es/docusaurus-plugin-content-docs/current/core/pipelines.md","sourceDirName":"core","slug":"/core/pipelines","permalink":"/rac-delta-docs/es/core/pipelines","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6},"sidebar":"tutorialSidebar","previous":{"title":"Servicios","permalink":"/rac-delta-docs/es/core/services"},"next":{"title":"Reference","permalink":"/rac-delta-docs/es/category/reference"}}');var a=o(4848),r=o(8453);const i={sidebar_position:6},d="Pipelines",l={},t=[{value:"Pipeline de subida",id:"pipeline-de-subida",level:2},{value:"Pipeline de subida base",id:"pipeline-de-subida-base",level:3},{value:"Pipeline de subida Hash",id:"pipeline-de-subida-hash",level:3},{value:"Pipeline de subida URL",id:"pipeline-de-subida-url",level:3},{value:"UploadOptions",id:"uploadoptions",level:3},{value:"<code>force</code>",id:"force",level:4},{value:"<code>requireRemoteIndex</code>",id:"requireremoteindex",level:4},{value:"<code>ignorePatterns</code>",id:"ignorepatterns",level:4},{value:"<code>onProgress</code>",id:"onprogress",level:4},{value:"<code>onStateChange</code>",id:"onstatechange",level:4},{value:"Pipeline de descarga",id:"pipeline-de-descarga",level:2},{value:"Pipeline de descarga base",id:"pipeline-de-descarga-base",level:3},{value:"Pipeline de descarga Hash",id:"pipeline-de-descarga-hash",level:3},{value:"Pipeline de descarga URL",id:"pipeline-de-descarga-url",level:3},{value:"UpdateStrategy",id:"updatestrategy",level:3},{value:"<code>DownloadAllFirstToMemory</code>",id:"downloadallfirsttomemory",level:4},{value:"<code>DownloadAllFirstToDisk</code>",id:"downloadallfirsttodisk",level:4},{value:"<code>StreamFromNetwork</code>",id:"streamfromnetwork",level:4},{value:"DownloadOptions",id:"downloadoptions",level:3},{value:"<code>force</code>",id:"force-1",level:4},{value:"<code>chunksSavePath</code>",id:"chunkssavepath",level:4},{value:"<code>useExistingIndex</code>",id:"useexistingindex",level:4},{value:"<code>fileReconstructionConcurrency</code>",id:"filereconstructionconcurrency",level:4},{value:"<code>inPlaceReconstructionThreshold</code>",id:"inplacereconstructionthreshold",level:4},{value:"<code>onProgress</code>",id:"onprogress-1",level:4},{value:"<code>onStateChange</code>",id:"onstatechange-1",level:4}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"pipelines",children:"Pipelines"})}),"\n",(0,a.jsx)(n.p,{children:"Pipelines son una forma opcional pero recomendada de unificar todos los servicios y configuraciones en una pipeline coherente que sigue el protocolo perfectamente."}),"\n",(0,a.jsxs)(n.p,{children:["De esta forma solo necesitas usarlo haciendo ",(0,a.jsx)(n.code,{children:"pipeline.execute(...)"})," y olvidarte de pasos extra."]}),"\n",(0,a.jsx)(n.h2,{id:"pipeline-de-subida",children:"Pipeline de subida"}),"\n",(0,a.jsx)(n.p,{children:"La primera pipeline es la de subida, esta sigue el protocolo rac-delta para subir una nueva versi\xf3n de tu build escaneando el directorio local, generando un rd-index.json, comparando, y parcheando lo cambios. Todo esto usando tu configuraci\xf3n actual."}),"\n",(0,a.jsx)(n.h3,{id:"pipeline-de-subida-base",children:"Pipeline de subida base"}),"\n",(0,a.jsx)(n.p,{children:"Al igual que el adaptador de almacenamiento, la pipeline de subida tambi\xe9n necesita una clase base, ya que tendr\xe1 versiones Hash y Url, con distintos par\xe1metros y comportamientos ligeramente diferentes."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"type UploadState = 'uploading' | 'comparing' | 'cleaning' | 'finalizing' | 'scanning';\n\nabstract class BaseUploadPipeline {\n  protected updateProgress(\n    value: number,\n    state: 'upload' | 'deleting',\n    speed?: number,\n    options?: UploadOptions\n  ) {\n    options?.onProgress?.(state, value, speed);\n  }\n\n  protected changeState(state: UploadState, options?: UploadOptions) {\n    options?.onStateChange?.(state);\n  }\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"pipeline-de-subida-hash",children:"Pipeline de subida Hash"}),"\n",(0,a.jsx)(n.p,{children:"Esta pipeline ser\xe1 la que se use para casi todas las implementaciones de almacenamiento (S3, SSH, Azure...) excepto la de URL (urls firmadas)"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:'title="Ejemplo de clase abastracta HashUploadPipeline en TS"',children:"abstract class HashUploadPipeline extends BaseUploadPipeline {\n  constructor(\n    protected readonly storage: HashStorageAdapter,\n    protected readonly delta: DeltaService,\n    protected readonly config: RacDeltaConfig\n  ) {\n    super();\n  }\n\n  abstract execute(\n    directory: string,\n    remoteIndex?: RDIndex,\n    options?: UploadOptions\n  ): Promise<RDIndex>;\n\n  abstract scanDirectory(dir: string, ignorePatterns?: string[]): Promise<RDIndex>;\n\n  abstract uploadMissingChunks(\n    plan: DeltaPlan,\n    baseDir: string,\n    force: boolean,\n    options?: UploadOptions\n  ): Promise<void>;\n\n  abstract deleteObsoleteChunks(plan: DeltaPlan, options?: UploadOptions): Promise<void>;\n\n  abstract uploadIndex(index: RDIndex): Promise<void>;\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"pipeline-de-subida-url",children:"Pipeline de subida URL"}),"\n",(0,a.jsx)(n.p,{children:"Esta pipeline ser\xe1 la que se use para el almacenamiento URL (URLs firmadas)"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:'title="Ejemplo de clase abstracta UrlUploadPipeline en TS"',children:"abstract class UrlUploadPipeline extends BaseUploadPipeline {\n  constructor(\n    protected readonly storage: UrlStorageAdapter,\n    protected readonly config: RacDeltaConfig\n  ) {\n    super();\n  }\n\n  abstract execute(\n    localIndex: RDIndex,\n    urls: {\n      uploadUrls: Record<string, ChunkUrlInfo>;\n      deleteUrls?: string[];\n      indexUrl: string;\n    },\n    options?: UploadOptions\n  ): Promise<RDIndex>;\n\n  abstract uploadMissingChunks(\n    uploadUrls: Record<string, ChunkUrlInfo>,\n    options?: UploadOptions\n  ): Promise<void>;\n\n  abstract uploadIndex(index: RDIndex, uploadUrl: string): Promise<void>;\n\n  abstract deleteObsoleteChunks(deleteUrls: string[], options?: UploadOptions): Promise<void>;\n}\n\ninterface ChunkUrlInfo {\n  url: string;\n  offset: number;\n  size: number;\n  filePath: string;\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Como puedes ver, los nombres de los m\xe9todos y las propiedades son diferentes. En este caso, el usuario debe proporcionar las urls. Da por hecho que la API que proporciona estas URLs ya ha comparado los \xedndices y creado un ",(0,a.jsx)(n.code,{children:"DeltaPlan"})," para conseguir las urls correctas."]}),"\n",(0,a.jsx)(n.h3,{id:"uploadoptions",children:"UploadOptions"}),"\n",(0,a.jsx)(n.p,{children:"Para mejor personalizaci\xf3n y rendimiento de la pipeline, algunos par\xe1metros opcionales pueden usarse:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"interface UploadOptions {\n  force?: boolean;\n  requireRemoteIndex?: boolean;\n  ignorePatterns?: string[];\n  onProgress?: (type: 'upload' | 'deleting', progress: number, speed?: number) => void;\n  onStateChange?: (state: UploadState) => void;\n}\n"})}),"\n",(0,a.jsx)(n.h4,{id:"force",children:(0,a.jsx)(n.code,{children:"force"})}),"\n",(0,a.jsxs)(n.p,{children:["Si es true, fuerza una subida completa incluso si existe un \xedndice remoto. Si es false, solo los chunks nuevos y modificados se subir\xe1n. (",(0,a.jsx)(n.code,{children:"boolean"}),")"]}),"\n",(0,a.jsx)(n.h4,{id:"requireremoteindex",children:(0,a.jsx)(n.code,{children:"requireRemoteIndex"})}),"\n",(0,a.jsxs)(n.p,{children:["Si es true y no hay \xedndice remoto, se aborta la subida. Si es falso (por defecto), sube todo si no se encuentra un \xedndice remoto. (",(0,a.jsx)(n.code,{children:"boolean"}),")"]}),"\n",(0,a.jsx)(n.h4,{id:"ignorepatterns",children:(0,a.jsx)(n.code,{children:"ignorePatterns"})}),"\n",(0,a.jsxs)(n.p,{children:["Archivos o directorios que deben ser ignorados al crear el rd-index.json. (",(0,a.jsx)(n.code,{children:"string[]"}),")"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Ejemplo: ",(0,a.jsx)(n.code,{children:"['*.ts', '/folder/*', 'ignorefile.txt']"})]}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"onprogress",children:(0,a.jsx)(n.code,{children:"onProgress"})}),"\n",(0,a.jsx)(n.p,{children:"Callback opcional para informar progreso."}),"\n",(0,a.jsx)(n.h4,{id:"onstatechange",children:(0,a.jsx)(n.code,{children:"onStateChange"})}),"\n",(0,a.jsx)(n.p,{children:"Callback opcional para los cambios de estado."}),"\n",(0,a.jsx)(n.h2,{id:"pipeline-de-descarga",children:"Pipeline de descarga"}),"\n",(0,a.jsx)(n.p,{children:"La segunda pipeline es la de descarga, esta es un poco m\xe1s compleja, ya que la reconstrucci\xf3n de archivos entra en juego (para esto veremos UpdateStrategy m\xe1s abajo)"}),"\n",(0,a.jsx)(n.h3,{id:"pipeline-de-descarga-base",children:"Pipeline de descarga base"}),"\n",(0,a.jsx)(n.p,{children:"Como la pipeline de subida, esta tambi\xe9n se divide en Hash y Url, as\xed que necesita una pipeline base para implementaciones compartidas:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"abstract class DownloadPipeline {\n  protected updateProgress(\n    value: number,\n    state: 'download' | 'reconstructing' | 'deleting',\n    diskUsage?: number,\n    speed?: number,\n    options?: DownloadOptions\n  ) {\n    options?.onProgress?.(state, value, diskUsage, speed);\n  }\n\n  protected changeState(\n    state: 'downloading' | 'reconstructing' | 'cleaning' | 'scanning',\n    options?: DownloadOptions\n  ) {\n    options?.onStateChange?.(state);\n  }\n\n  abstract loadLocalIndex(dir: string): Promise<RDIndex>;\n\n  abstract findLocalIndex(localDir: string): Promise<RDIndex | null>;\n\n  abstract verifyAndDeleteObsoleteChunks(\n    plan: DeltaPlan,\n    localDir: string,\n    remoteIndex: RDIndex,\n    chunkSource: ChunkSource,\n    options?: DownloadOptions\n  ): Promise<{ deletedFiles: string[]; verifiedFiles: string[]; rebuiltFiles: string[] }>;\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"pipeline-de-descarga-hash",children:"Pipeline de descarga Hash"}),"\n",(0,a.jsx)(n.p,{children:"Esta pipeline ser\xe1 la que usar\xe1 la mayor\xeda de implementaciones de almacenamiento (S3, SSH, Azure...) excepto la de URL (para URLs firmadas)"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:'title="Ejemplo de clase abstracta HashDownloadPipeline en TS"',children:"export abstract class HashDownloadPipeline extends DownloadPipeline {\n  constructor(\n    protected readonly storage: HashStorageAdapter,\n    protected readonly delta: DeltaService,\n    protected readonly reconstruction: ReconstructionService,\n    protected readonly validation: ValidationService,\n    protected readonly config: RacDeltaConfig\n  ) {\n    super();\n  }\n\n  abstract execute(\n    localDir: string,\n    strategy: UpdateStrategy,\n    remoteIndex?: RDIndex,\n    options?: DownloadOptions\n  ): Promise<void>;\n\n  abstract saveLocalIndex(localDir: string, index: RDIndex): Promise<void>;\n\n  abstract downloadAllMissingChunks(\n    plan: DeltaPlan,\n    target: 'memory' | 'disk',\n    options?: DownloadOptions\n  ): Promise<ChunkSource>;\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"pipeline-de-descarga-url",children:"Pipeline de descarga URL"}),"\n",(0,a.jsx)(n.p,{children:"Esta pipeline ser\xe1 la usada para el almacenamiento URL (URLs firmadas)"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:'title="Ejemplo de abstracci\xf3n UrlDownloadPipeline en TS"',children:"abstract class UrlDownloadPipeline extends DownloadPipeline {\n  constructor(\n    protected readonly storage: UrlStorageAdapter,\n    protected readonly reconstruction: ReconstructionService,\n    protected readonly validation: ValidationService,\n    protected readonly delta: DeltaService,\n    protected readonly config: RacDeltaConfig\n  ) {\n    super();\n  }\n\n  abstract execute(\n    localDir: string,\n    urls: {\n      downloadUrls: Record<string, ChunkUrlInfo>;\n      indexUrl: string;\n    },\n    strategy: UpdateStrategy,\n    plan?: DeltaPlan,\n    options?: DownloadOptions\n  ): Promise<void>;\n\n  abstract saveLocalIndex(localDir: string, index: RDIndex): Promise<void>;\n\n  abstract downloadAllMissingChunks(\n    downloadUrls: Record<string, ChunkUrlInfo>,\n    target: 'memory' | 'disk',\n    options?: DownloadOptions\n  ): Promise<ChunkSource>;\n}\n\ninterface ChunkUrlInfo {\n  url: string;\n  offset: number;\n  size: number;\n  filePath: string;\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"updatestrategy",children:"UpdateStrategy"}),"\n",(0,a.jsxs)(n.p,{children:["Para unas pipelines m\xe1s personalizadas, recomendamos el uso de ",(0,a.jsx)(n.code,{children:"UpdateStrategy"}),", este enum har\xe1 disponible distintas formas de descargar y reconstruir los archivos."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"enum UpdateStrategy {\n  DownloadAllFirstToMemory = 'download-all-first-to-memory',\n\n  StreamFromNetwork = 'stream-from-network',\n\n  DownloadAllFirstToDisk = 'download-all-first-to-disk',\n}\n"})}),"\n",(0,a.jsx)(n.h4,{id:"downloadallfirsttomemory",children:(0,a.jsx)(n.code,{children:"DownloadAllFirstToMemory"})}),"\n",(0,a.jsx)(n.p,{children:"Descarga todos los chunks antes de reconstruir y los guarda en memoria.\nPerfecto para conexiones r\xe1pidas y reconstrucci\xf3n offline."}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"NOTA"}),": Para actualizaciones grandes esta opci\xf3n no se recomienda, ya que puede usar mucha memoria."]}),"\n",(0,a.jsx)(n.h4,{id:"downloadallfirsttodisk",children:(0,a.jsx)(n.code,{children:"DownloadAllFirstToDisk"})}),"\n",(0,a.jsx)(n.p,{children:"Descarga todos los chunks antes de reconstruir y los guarda en disco en la ruta especificada. Perfecto para conexiones r\xe1pidas, discos r\xe1pidos y reconstrucci\xf3n offline."}),"\n",(0,a.jsx)(n.h4,{id:"streamfromnetwork",children:(0,a.jsx)(n.code,{children:"StreamFromNetwork"})}),"\n",(0,a.jsx)(n.p,{children:"Descarga chunks bajo demanda mientras reconstruye. \xdatil para entornos con recursos limitados o streaming progresivo."}),"\n",(0,a.jsx)(n.h3,{id:"downloadoptions",children:"DownloadOptions"}),"\n",(0,a.jsx)(n.p,{children:"Para mejor personalizaci\xf3n y rendimiento de la pipeline, se puede usar configuraciones opcionales:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"interface DownloadOptions {\n  force?: boolean;\n  chunksSavePath?: string;\n  useExistingIndex?: boolean;\n  fileReconstructionConcurrency?: number;\n  inPlaceReconstructionThreshold?: number;\n  onProgress?: (\n    type: 'download' | 'deleting' | 'reconstructing',\n    progress: number,\n    diskUsage?: number,\n    speed?: number\n  ) => void;\n  onStateChange?: (state: 'downloading' | 'reconstructing' | 'cleaning' | 'scanning') => void;\n}\n"})}),"\n",(0,a.jsx)(n.h4,{id:"force-1",children:(0,a.jsx)(n.code,{children:"force"})}),"\n",(0,a.jsxs)(n.p,{children:["Si es true, lo descarga todo. Si es false, solo descargar\xe1 los chunks nuevos y modificados. (",(0,a.jsx)(n.code,{children:"boolean"}),")"]}),"\n",(0,a.jsx)(n.h4,{id:"chunkssavepath",children:(0,a.jsx)(n.code,{children:"chunksSavePath"})}),"\n",(0,a.jsxs)(n.p,{children:["Ruta donde los chunks se guardar\xe1n si la estrategia ",(0,a.jsx)(n.code,{children:"DownloadAllFirstToDisk"})," es seleccionada. (",(0,a.jsx)(n.code,{children:"string"}),")"]}),"\n",(0,a.jsx)(n.h4,{id:"useexistingindex",children:(0,a.jsx)(n.code,{children:"useExistingIndex"})}),"\n",(0,a.jsxs)(n.p,{children:["Si es true, buscar\xe1 primero un rd-index existente en el directorio local. Esta opci\xf3n no es recomendada, ya que generar un nuevo rd-index es siempre la mejor forma de detectar cambios o corrupci\xf3n. (",(0,a.jsx)(n.code,{children:"boolean"}),")"]}),"\n",(0,a.jsx)(n.h4,{id:"filereconstructionconcurrency",children:(0,a.jsx)(n.code,{children:"fileReconstructionConcurrency"})}),"\n",(0,a.jsxs)(n.p,{children:["Cu\xe1ntos archivos se reconstruir\xe1n concurrentemente. (Por defecto es 5) (",(0,a.jsx)(n.code,{children:"number"}),")"]}),"\n",(0,a.jsx)(n.h4,{id:"inplacereconstructionthreshold",children:(0,a.jsx)(n.code,{children:"inPlaceReconstructionThreshold"})}),"\n",(0,a.jsxs)(n.p,{children:["Tama\xf1o de archivo m\xednimo (en bytes) necesarios para realizar una ",(0,a.jsx)(n.strong,{children:"reconstrucci\xf3n in-place"})," en lugar de usar un archivo temporal.\nPor defecto: ",(0,a.jsx)(n.code,{children:"400 * 1024 * 1024"})," (400 MB)."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Reconstrucci\xf3n in-place:"}),"\nEl archivo existente es abierto y actualizado directamente sobreescribiendo solo los chunks modificados o nuevos."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Reconstrucci\xf3n .tmp:"}),"\nEl archivo es completamente reconstruido en un ",(0,a.jsx)(n.code,{children:".tmp"})," usando todos los chunks (nuevos y existentes), luego reemplaza el archivo original."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Cu\xe1ndo usar:"}),"\nLa reconstrucci\xf3n in-place se recomienda para ",(0,a.jsx)(n.strong,{children:"archivos grandes"}),", ya que evita reescribir el archivo entero y reduce significativamente el uso del espacio del disco.\nSin embargo, puede ser ",(0,a.jsx)(n.strong,{children:"inseguro para ciertos formatos"})," (ejemplo, archivos ZIP o bases de datos) que son sensibles a la escritura parcial o la corrupci\xf3n.\nPara deshabilitar la reconstrucci\xf3n in-place por completo, pon este valor como ",(0,a.jsx)(n.code,{children:"0"}),"."]}),"\n",(0,a.jsx)(n.h4,{id:"onprogress-1",children:(0,a.jsx)(n.code,{children:"onProgress"})}),"\n",(0,a.jsx)(n.p,{children:"Callback opcional para informar progreso."}),"\n",(0,a.jsx)(n.h4,{id:"onstatechange-1",children:(0,a.jsx)(n.code,{children:"onStateChange"})}),"\n",(0,a.jsx)(n.p,{children:"Callback opcional para cambios de estado."})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},8453:(e,n,o)=>{o.d(n,{R:()=>i,x:()=>d});var s=o(6540);const a={},r=s.createContext(a);function i(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);