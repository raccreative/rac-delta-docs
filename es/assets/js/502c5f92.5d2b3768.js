"use strict";(globalThis.webpackChunkrac_delta_docs=globalThis.webpackChunkrac_delta_docs||[]).push([[4217],{838:(e,o,r)=>{r.r(o),r.d(o,{assets:()=>c,contentTitle:()=>d,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"protocol/synchronization-process","title":"Proceso de sincronizaci\xf3n","description":"Para poder sincronizar archivos para subir o descargar, el protocolo describe c\xf3mo deber\xeda hacerse para un mejor flujo de trabajo.","source":"@site/i18n/es/docusaurus-plugin-content-docs/current/protocol/synchronization-process.md","sourceDirName":"protocol","slug":"/protocol/synchronization-process","permalink":"/rac-delta-docs/es/protocol/synchronization-process","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"rd-index.json","permalink":"/rac-delta-docs/es/protocol/rd-index.json"},"next":{"title":"Seguridad","permalink":"/rac-delta-docs/es/protocol/security"}}');var n=r(4848),a=r(8453);const i={sidebar_position:3},d="Proceso de sincronizaci\xf3n",c={},l=[{value:"Subida",id:"subida",level:2},{value:"1. Generar el rd-index local",id:"1-generar-el-rd-index-local",level:3},{value:"2. Conseguir el rd-index remoto",id:"2-conseguir-el-rd-index-remoto",level:3},{value:"3. Comparando archivos rd-index",id:"3-comparando-archivos-rd-index",level:3},{value:"4. Subir nuevos chunks",id:"4-subir-nuevos-chunks",level:3},{value:"5. Limpiar los chunks y archivos remotos obsoletos",id:"5-limpiar-los-chunks-y-archivos-remotos-obsoletos",level:3},{value:"6. Subir el nuevo rd-index.json",id:"6-subir-el-nuevo-rd-indexjson",level:3},{value:"Descarga",id:"descarga",level:2},{value:"1. rd-index. local",id:"1-rd-index-local",level:3},{value:"2. rd-index.json remoto",id:"2-rd-indexjson-remoto",level:3},{value:"3. Comparar \xedndices",id:"3-comparar-\xedndices",level:3},{value:"4. Descargar chunks y reconstruir archivos",id:"4-descargar-chunks-y-reconstruir-archivos",level:3},{value:"5. Limpiar archivos o chunks obsoletos",id:"5-limpiar-archivos-o-chunks-obsoletos",level:3},{value:"6. Reemplazar el rd-index.json local",id:"6-reemplazar-el-rd-indexjson-local",level:3}];function t(e){const o={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(o.header,{children:(0,n.jsx)(o.h1,{id:"proceso-de-sincronizaci\xf3n",children:"Proceso de sincronizaci\xf3n"})}),"\n",(0,n.jsx)(o.p,{children:"Para poder sincronizar archivos para subir o descargar, el protocolo describe c\xf3mo deber\xeda hacerse para un mejor flujo de trabajo."}),"\n",(0,n.jsx)(o.h2,{id:"subida",children:"Subida"}),"\n",(0,n.jsx)(o.p,{children:"Los pasos para sincronizar una subida usando rac-delta est\xe1n redactados aqu\xed:"}),"\n",(0,n.jsx)(o.h3,{id:"1-generar-el-rd-index-local",children:"1. Generar el rd-index local"}),"\n",(0,n.jsx)(o.p,{children:"Lo primero de todo, debemos generar el \xedndice local del directorio que queremos subir y sincronizar con el almacenamiento remoto. Este proceso se puede hacer usando un servicio delta propio (echa un ojo a core), o usando los SDKs disponibles con su servicio delta y su pipeline de subida."}),"\n",(0,n.jsxs)(o.p,{children:["Para generar un rd-index.json local, simplemente itera sobre tu directorio usando el sistema de archivos y divide los archivos usando un tama\xf1o de chunk (se recomienda 1MB), entonces calcula el hash de cada chunk y crea el archivo ",(0,n.jsx)(o.a,{href:"/protocol/rd-index.json",children:"rd-index.json"}),"."]}),"\n",(0,n.jsx)(o.p,{children:"El algoritmo de hash recomendado para rac-delta es Blake3."}),"\n",(0,n.jsx)(o.p,{children:"Tambi\xe9n recomendamos generar el rd-index.json con concurrencia, los SDKs de rac-delta implementan tama\xf1os de chunk y l\xedmites de concurrencia personalizados. Adem\xe1s, los SDKs tambi\xe9n implementan soporte para streaming para la generaci\xf3n del rd-index."}),"\n",(0,n.jsx)(o.h3,{id:"2-conseguir-el-rd-index-remoto",children:"2. Conseguir el rd-index remoto"}),"\n",(0,n.jsx)(o.p,{children:"Para poder comparar \xedndices, necesitas proporcionar el rd-index.json remoto, ya sea manualmente o usando el adaptador de almacenamiento de tu proveedor (S3, Azure, GCS...)"}),"\n",(0,n.jsx)(o.p,{children:"Si no se proporciona ning\xfan rd-index remoto, todo se subir\xe1."}),"\n",(0,n.jsx)(o.h3,{id:"3-comparando-archivos-rd-index",children:"3. Comparando archivos rd-index"}),"\n",(0,n.jsx)(o.p,{children:"Comparar el \xedndice local con el remoto dar\xe1 como resultado un Delta Plan, un objecto que lucir\xe1 como:"}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",children:"DeltaPlan {\n  newAndModifiedFiles: FileEntry[];\n  deletedFiles: string[];\n  missingChunks: ChunkEntry[];\n  obsoleteChunks: ChunkEntry[];\n}\n"})}),"\n",(0,n.jsxs)(o.ul,{children:["\n",(0,n.jsxs)(o.li,{children:[(0,n.jsx)(o.strong,{children:"newAndModifiedFiles"}),": Lista de los archivos que son nuevos o se han modificado, cada archivo es un objeto que incluye la ruta relativa del archivo, su hash y su lista de chunks."]}),"\n",(0,n.jsxs)(o.li,{children:[(0,n.jsx)(o.strong,{children:"deletedFiles"}),": Lista de las rutas relativas de los archivos que ya no existen en el directorio objetivo y ser\xe1n eliminados."]}),"\n",(0,n.jsxs)(o.li,{children:[(0,n.jsx)(o.strong,{children:"missingChunks"}),": Lista de los chunks nuevos que ser\xe1n subidos o descargados, incluye el archivo padre y su hash."]}),"\n",(0,n.jsxs)(o.li,{children:[(0,n.jsx)(o.strong,{children:"obsoleteChunks"}),": Lista de chunks que ya no forman parte de archivos existentes. Normalmente estos chunks ya se reemplazan con chunks nuevos, pero deben ser verificados para evitar corrupci\xf3n."]}),"\n"]}),"\n",(0,n.jsx)(o.p,{children:"Con esta informaci\xf3n, est\xe1s listo para subir nuevos chunks."}),"\n",(0,n.jsx)(o.h3,{id:"4-subir-nuevos-chunks",children:"4. Subir nuevos chunks"}),"\n",(0,n.jsx)(o.p,{children:"Ahora simplemente sube los chunks usando la informaci\xf3n del Delta Plan, este paso se har\xe1 usando tu adaptador de almacenamiento elegido (S3, Azure, SSH...)."}),"\n",(0,n.jsx)(o.h3,{id:"5-limpiar-los-chunks-y-archivos-remotos-obsoletos",children:"5. Limpiar los chunks y archivos remotos obsoletos"}),"\n",(0,n.jsx)(o.p,{children:"Tras subir los chunks, debes asegurarte de que los archivos y chunks obsoletos se han eliminado del directorio remoto, normalmente usando el mismo adaptador de almacenamiento."}),"\n",(0,n.jsxs)(o.p,{children:[(0,n.jsx)(o.strong,{children:"Nota:"})," Algunos chunks pueden ser usados en distintos archivos, as\xed que es importante no marcarlos como obsoletos si se usan en otros archivos, ya que el almacenamiento deber\xeda solo guardar chunks con deduplicaci\xf3n."]}),"\n",(0,n.jsx)(o.h3,{id:"6-subir-el-nuevo-rd-indexjson",children:"6. Subir el nuevo rd-index.json"}),"\n",(0,n.jsx)(o.p,{children:"Despu\xe9s de que todo est\xe9 terminado, el \xfaltimo paso es subir el nuevo rd-index.json generado al directorio remoto, para que el \xedndice est\xe9 actualizado de cara a futuras operaciones."}),"\n",(0,n.jsx)(o.h2,{id:"descarga",children:"Descarga"}),"\n",(0,n.jsx)(o.p,{children:"Los pasos para sincronizar una descarga usando rad-delta se redactan aqu\xed:"}),"\n",(0,n.jsx)(o.h3,{id:"1-rd-index-local",children:"1. rd-index. local"}),"\n",(0,n.jsx)(o.p,{children:"Para las descargas, puedes generar un nuevo rd-index.json desde tu directorio, o proporcionar uno existente. El rd-index.json se dejar\xe1 dentro del directorio tras la descarga, as\xed que si nada ha cambiado puedes usarlo, sin embargo, se recomienda generar siempre uno nuevo para asegurar que todo est\xe1 registrado."}),"\n",(0,n.jsx)(o.p,{children:"Si no se proporciona un rd-index.json local, todo ser\xe1 descargado."}),"\n",(0,n.jsx)(o.h3,{id:"2-rd-indexjson-remoto",children:"2. rd-index.json remoto"}),"\n",(0,n.jsx)(o.p,{children:"Un rd-index.json remoto debe ser proporcionado, ya que es la fuente de los chunks a descargar. Puedes proporcionar uno manualmente o descargarlo usando tu adaptador de almacenamiento."}),"\n",(0,n.jsx)(o.h3,{id:"3-comparar-\xedndices",children:"3. Comparar \xedndices"}),"\n",(0,n.jsxs)(o.p,{children:["Compara los dos rd-index.json para generar un Delta Plan, echa un ojo a ",(0,n.jsx)(o.a,{href:"#3-comparing-rd-index-files",children:"Comparar archivos rd-index"})," arriba."]}),"\n",(0,n.jsx)(o.h3,{id:"4-descargar-chunks-y-reconstruir-archivos",children:"4. Descargar chunks y reconstruir archivos"}),"\n",(0,n.jsx)(o.p,{children:"El protocolo no fuerza a un m\xe9todo de descarga y reconstrucci\xf3n, pero tenemos 3 estrategias recomendadas que se implementan en los SDKs disponibles."}),"\n",(0,n.jsxs)(o.ul,{children:["\n",(0,n.jsxs)(o.li,{children:[(0,n.jsx)(o.strong,{children:"Descargar todos los chunks primero en memoria"}),": Esta estrategia descargar\xe1 primero todos los chunks en memoria, y reconstruir\xe1 los archivos despu\xe9s. Esta opci\xf3n es mejor para redes lentas y peque\xf1os directorios, reconstruir\xe1 m\xe1s r\xe1pido y la concurrencia es recomendable."]}),"\n",(0,n.jsxs)(o.li,{children:[(0,n.jsx)(o.strong,{children:"Descargar todos los chunks primero en disco"}),": Esta estrategia es similar a la de la memoria, pero lo descarga todo a disco, esta opci\xf3n es mejor para m\xe1quinas con poca memoria, pero requiere m\xe1s espacio temporal en disco."]}),"\n",(0,n.jsxs)(o.li,{children:[(0,n.jsx)(o.strong,{children:"Streaming de chunks y reconstrucci\xf3n"}),": Esta estrategia reconstruir\xe1 los archivos mientras se descargan los chunks v\xeda streaming, esta es la opci\xf3n recomendada ya que no usar\xe1 memoria ni disco, pero puede consumir m\xe1s ancho de banda y necesitar m\xe1s uso de CPU."]}),"\n"]}),"\n",(0,n.jsx)(o.p,{children:"Tras eso, recomendamos que los usuarios verifiquen el archivo final usando el hash para asegurarse de que la reconstrucci\xf3n ha salido bien."}),"\n",(0,n.jsx)(o.h3,{id:"5-limpiar-archivos-o-chunks-obsoletos",children:"5. Limpiar archivos o chunks obsoletos"}),"\n",(0,n.jsx)(o.p,{children:"Despu\xe9s de que los nuevos chunks hayan sido descargados y reconstruidos, tenemos que asegurarnos de que los archivos obsoletos se han eliminado, y los chunks obsoletos ya no est\xe1n presentes en nuestra build para evitar corrupci\xf3n de archivos. Puedes verificar la integridad del archivo f\xe1cilmente con los SDKs disponibles."}),"\n",(0,n.jsx)(o.h3,{id:"6-reemplazar-el-rd-indexjson-local",children:"6. Reemplazar el rd-index.json local"}),"\n",(0,n.jsx)(o.p,{children:"El \xfaltimo paso es guardar el nuevo rd-index.json en tu directorio local para futuras operaciones."})]})}function u(e={}){const{wrapper:o}={...(0,a.R)(),...e.components};return o?(0,n.jsx)(o,{...e,children:(0,n.jsx)(t,{...e})}):t(e)}},8453:(e,o,r)=>{r.d(o,{R:()=>i,x:()=>d});var s=r(6540);const n={},a=s.createContext(n);function i(e){const o=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(o):{...o,...e}},[o,e])}function d(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:i(e.components),s.createElement(a.Provider,{value:o},e.children)}}}]);