"use strict";(globalThis.webpackChunkrac_delta_docs=globalThis.webpackChunkrac_delta_docs||[]).push([[6135],{1470:(e,n,a)=>{a.d(n,{A:()=>_});var r=a(6540),t=a(4164),s=a(7559),i=a(3104),o=a(6347),l=a(205),c=a(7485),u=a(1682),d=a(679);function h(e){return r.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}function m(e){const{values:n,children:a}=e;return(0,r.useMemo)(()=>{const e=n??function(e){return h(e).map(({props:{value:e,label:n,attributes:a,default:r}})=>({value:e,label:n,attributes:a,default:r}))}(a);return function(e){const n=(0,u.XI)(e,(e,n)=>e.value===n.value);if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map(e=>e.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e},[n,a])}function p({value:e,tabValues:n}){return n.some(n=>n.value===e)}function f({queryString:e=!1,groupId:n}){const a=(0,o.W6)(),t=function({queryString:e=!1,groupId:n}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,c.aZ)(t),(0,r.useCallback)(e=>{if(!t)return;const n=new URLSearchParams(a.location.search);n.set(t,e),a.replace({...a.location,search:n.toString()})},[t,a])]}function v(e){const{defaultValue:n,queryString:a=!1,groupId:t}=e,s=m(e),[i,o]=(0,r.useState)(()=>function({defaultValue:e,tabValues:n}){if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!p({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map(e=>e.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const a=n.find(e=>e.default)??n[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:n,tabValues:s})),[c,u]=f({queryString:a,groupId:t}),[h,v]=function({groupId:e}){const n=function(e){return e?`docusaurus.tab.${e}`:null}(e),[a,t]=(0,d.Dv)(n);return[a,(0,r.useCallback)(e=>{n&&t.set(e)},[n,t])]}({groupId:t}),g=(()=>{const e=c??h;return p({value:e,tabValues:s})?e:null})();(0,l.A)(()=>{g&&o(g)},[g]);return{selectedValue:i,selectValue:(0,r.useCallback)(e=>{if(!p({value:e,tabValues:s}))throw new Error(`Can't select invalid tab value=${e}`);o(e),u(e),v(e)},[u,v,s]),tabValues:s}}var g=a(2303);const x={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var b=a(4848);function S({className:e,block:n,selectedValue:a,selectValue:r,tabValues:s}){const o=[],{blockElementScrollPositionUntilNextRender:l}=(0,i.a_)(),c=e=>{const n=e.currentTarget,t=o.indexOf(n),i=s[t].value;i!==a&&(l(n),r(i))},u=e=>{let n=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const a=o.indexOf(e.currentTarget)+1;n=o[a]??o[0];break}case"ArrowLeft":{const a=o.indexOf(e.currentTarget)-1;n=o[a]??o[o.length-1];break}}n?.focus()};return(0,b.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,t.A)("tabs",{"tabs--block":n},e),children:s.map(({value:e,label:n,attributes:r})=>(0,b.jsx)("li",{role:"tab",tabIndex:a===e?0:-1,"aria-selected":a===e,ref:e=>{o.push(e)},onKeyDown:u,onClick:c,...r,className:(0,t.A)("tabs__item",x.tabItem,r?.className,{"tabs__item--active":a===e}),children:n??e},e))})}function y({lazy:e,children:n,selectedValue:a}){const s=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const e=s.find(e=>e.props.value===a);return e?(0,r.cloneElement)(e,{className:(0,t.A)("margin-top--md",e.props.className)}):null}return(0,b.jsx)("div",{className:"margin-top--md",children:s.map((e,n)=>(0,r.cloneElement)(e,{key:n,hidden:e.props.value!==a}))})}function j(e){const n=v(e);return(0,b.jsxs)("div",{className:(0,t.A)(s.G.tabs.container,"tabs-container",x.tabList),children:[(0,b.jsx)(S,{...n,...e}),(0,b.jsx)(y,{...n,...e})]})}function _(e){const n=(0,g.A)();return(0,b.jsx)(j,{...e,children:h(e.children)},String(n))}},8951:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>d,contentTitle:()=>u,default:()=>p,frontMatter:()=>c,metadata:()=>r,toc:()=>h});const r=JSON.parse('{"id":"usage/services","title":"Servicios","description":"El SDK de rac-delta tiene 4 servicios que ser\xe1n responsables de todas las operaciones de las pipelines, y pueden ser usados de forma individual para operaciones personalizadas o personalizaci\xf3n de pipelines.","source":"@site/i18n/es/docusaurus-plugin-content-docs/current/usage/services.mdx","sourceDirName":"usage","slug":"/usage/services","permalink":"/rac-delta-docs/es/usage/services","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Descargas","permalink":"/rac-delta-docs/es/usage/downloading"},"next":{"title":"Adaptador de almacenamiento","permalink":"/rac-delta-docs/es/usage/storage-adapter"}}');var t=a(4848),s=a(8453),i=a(1470),o=a(9365),l=a(3457);const c={sidebar_position:4},u="Servicios",d={},h=[{value:"Servicio de hasher",id:"servicio-de-hasher",level:2},{value:"Servicio de validaci\xf3n",id:"servicio-de-validaci\xf3n",level:2},{value:"Servicio delta",id:"servicio-delta",level:2},{value:"Streaming",id:"streaming",level:3},{value:"Servicio de reconstrucci\xf3n",id:"servicio-de-reconstrucci\xf3n",level:2},{value:"Streaming",id:"streaming-1",level:3}];function m(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",strong:"strong",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"servicios",children:"Servicios"})}),"\n",(0,t.jsxs)(n.p,{children:["El SDK de ",(0,t.jsx)(n.strong,{children:"rac-delta"})," tiene 4 servicios que ser\xe1n responsables de todas las operaciones de las pipelines, y pueden ser usados de forma individual para operaciones personalizadas o personalizaci\xf3n de pipelines."]}),"\n",(0,t.jsx)(n.h2,{id:"servicio-de-hasher",children:"Servicio de hasher"}),"\n",(0,t.jsxs)(n.p,{children:["El servicio de hasher se encarga de implementar el hashing para crear los hashes de los archivos y los chunks, para verificar la integridad y para generar los objetos ",(0,t.jsx)(n.code,{children:"FileEntry"})," y ",(0,t.jsx)(n.code,{children:"Chunk"})," con sus hashes."]}),"\n",(0,t.jsxs)(n.p,{children:["Nuestra versi\xf3n de ",(0,t.jsx)(n.strong,{children:"NodeJs"})," usa HashWasm con blake3 para esto, y la versi\xf3n de ",(0,t.jsx)(n.strong,{children:"Rust"})," usa la crate blake3."]}),"\n",(0,t.jsxs)(n.p,{children:["Tiene soporte para stream usando el m\xe9todo ",(0,t.jsx)(n.code,{children:"streamHash"}),", que generar\xe1 un objeto ",(0,t.jsx)(n.code,{children:"Chunk"}),". Puedes usarlo para generar el array de chunks de un archivo, pero el servicio delta ya implementa un m\xe9todo de streaming que usa esto."]}),"\n",(0,t.jsxs)(i.A,{children:[(0,t.jsxs)(o.A,{value:"node",label:"Node.js",children:[(0,t.jsx)("h4",{children:"Ejemplo de uso del servicio hasher:"}),(0,t.jsx)(l.A,{className:"language-ts",children:"\n  // Hasheamos un archivo y retorna un fileEntry, que contiene meta datos y una lista de sus chunks (y sus hashes)\n  const fileEntry = await racDeltaClient.hasher.hashFile('my-dir/file.txt', 'my-dir', 1024 * 1024);\n  "})]}),(0,t.jsxs)(o.A,{value:"rust",label:"Rust",children:[(0,t.jsx)("h4",{children:"Ejemplo de uso del servicio hasher:"}),(0,t.jsx)(l.A,{className:"language-rust",children:'\n  // Hasheamos un archivo y retorna un fileEntry, que contiene meta datos y una lista de sus chunks (y sus hashes)\n  let file_entry = client.hasher.hash_file("dir/file.txt", "dir", 1024 * 1024).await?;\n  '})]})]}),"\n",(0,t.jsx)(n.h2,{id:"servicio-de-validaci\xf3n",children:"Servicio de validaci\xf3n"}),"\n",(0,t.jsx)(n.p,{children:"El servicio de validaci\xf3n se usa \xfanicamente para validar archivos e \xedndices. Usa el servicio de hash para ello. Tiene m\xe9todos b\xe1sicos que devuelven booleanos."}),"\n",(0,t.jsxs)(i.A,{children:[(0,t.jsxs)(o.A,{value:"node",label:"Node.js",children:[(0,t.jsx)("h4",{children:"Ejemplo de uso del servicio de validaci\xf3n:"}),(0,t.jsx)(l.A,{className:"language-ts",children:"\n  // Generamos un FileEntry o lo sacamos de nuestro rd-index.json\n  const fileEntry = await racDeltaClient.hasher.hashFile('my-dir/file.txt', 'my-dir', 1024 * 1024);\n\n  // Valida el hash del fileEntry con el verdadero hash del archivo\n  const valid = await racDeltaClient.validation.validateFile(fileEntry, 'my-dir/file.txt');\n  "})]}),(0,t.jsxs)(o.A,{value:"rust",label:"Rust",children:[(0,t.jsx)("h4",{children:"Ejemplo de uso del servicio de validaci\xf3n:"}),(0,t.jsx)(l.A,{className:"language-rust",children:'\n  // Generamos un FileEntry o lo sacamos de nuestro rd-index.json\n  let file_entry = client.hasher.hash_file("dir/file.txt", "dir", 1024 * 1024).await?;\n\n  // Valida el hash del fileEntry con el verdadero hash del archivo\n  let valid = client.validation.validate_file(&file_entry, "dir/file.txt").await?;\n  '})]})]}),"\n",(0,t.jsx)(n.h2,{id:"servicio-delta",children:"Servicio delta"}),"\n",(0,t.jsx)(n.p,{children:"El servicio delta se encarga principalmente de crear los rd-index, compararlos y mergearlos."}),"\n",(0,t.jsx)(n.p,{children:"Comparar dos archivos rd-index generar\xe1 un Delta Plan que incluir\xe1 los cambios a subir o descargar."}),"\n",(0,t.jsxs)(i.A,{children:[(0,t.jsxs)(o.A,{value:"node",label:"Node.js",children:[(0,t.jsx)("h4",{children:"Ejemplo de uso del servicio delta:"}),(0,t.jsx)(l.A,{className:"language-ts",children:"\n  // Genera un objeto rd-index a partir de un directorio, (ruta, tama\xf1o de chunk, concurrencia, patrones a ignorar)\n  const index = await racDeltaClient.delta.createIndexFromDirectory('my-dir', 1024 * 1024, 6, ['*.zip']);\n  "})]}),(0,t.jsxs)(o.A,{value:"rust",label:"Rust",children:[(0,t.jsx)("h4",{children:"Ejemplo de uso del servicio delta:"}),(0,t.jsx)(l.A,{className:"language-rust",children:'\n  // Genera un objeto rd-index a partir de un directorio, (ruta, tama\xf1o de chunk, concurrencia, patrones a ignorar)\n  let index = client.delta.create_index_from_directory(Path::new("my-dir"), 1024 * 1024, Some(6), Some(vec![String::from("*.zip")])).await?;\n  '})]})]}),"\n",(0,t.jsx)(n.h3,{id:"streaming",children:"Streaming"}),"\n",(0,t.jsx)(n.p,{children:"El servicio delta ofrece una forma de generar file entries v\xeda streaming, perfecto para casos de uso donde la memoria no abunda."}),"\n",(0,t.jsxs)(i.A,{children:[(0,t.jsxs)(o.A,{value:"node",label:"Node.js",children:[(0,t.jsx)("h4",{children:"Generar un rd-index v\xeda streaming:"}),(0,t.jsx)(l.A,{className:"language-ts",children:"\n  //\n  // Adapter: Readable \u2192 AsyncChunkStream\n  //\n  class ReadableChunkStream implements AsyncChunkStream {\n      private reader: AsyncIterable<Uint8Array>;\n\n      constructor(path: string, chunkSize: number) {\n          this.reader = createReadStream(path, {\n              highWaterMark: chunkSize,\n          });\n      }\n\n      async *[Symbol.asyncIterator]() {\n          for await (const chunk of this.reader) {\n              yield new Uint8Array(chunk);\n          }\n      }\n\n      async nextChunk(): Promise<Uint8Array | null> {\n          const iterator = this[Symbol.asyncIterator]();\n\n          const result = await iterator.next();\n\n          return result.done ? null : result.value;\n      }\n  }\n\n  const racDeltaClient = new RacDeltaClient({\n      chunkSize: 1024 * 1024,\n      maxConcurrency: 6,\n      storage: {\n          type: 'ssh',\n          host: 'localhost',\n          pathPrefix: '/root/upload',\n          port: 2222,\n          credentials: {\n              username: 'root',\n              password: 'password',\n          },\n      },\n  });\n\n  const files = await readdir('my-dir');\n  const entries: FileEntry[] = [];\n\n  for (const name of files) {\n      const full = join('my-dir', name);\n      const stats = await stat(full);\n\n      if (!stats.isFile()) {\n          continue;\n      }\n\n      const stream = new ReadableChunkStream(full, 1024 * 1024);\n\n      const entry = await racDeltaClient.delta.createFileEntryFromStream(stream, full);\n\n      entries.push(entry);\n  }\n\n  const rdIndex: RDIndex = {\n      version: 1,\n      createdAt: Date.now(),\n      chunkSize: 1024 * 1024,\n      files: entries,\n  };\n  "})]}),(0,t.jsxs)(o.A,{value:"rust",label:"Rust",children:[(0,t.jsx)("h4",{children:"Generar un rd-index v\xeda streaming:"}),(0,t.jsx)(l.A,{className:"language-rust",children:'\n  use async_trait::async_trait;\n  use tokio::fs::File;\n  use tokio::io::{AsyncReadExt, BufReader};\n  \n  pub struct ReadableChunkStream {\n    reader: BufReader<File>,\n    chunk_size: usize,\n  }\n  \n  impl ReadableChunkStream {\n    pub async fn new(path: &str, chunk_size: usize) -> std::io::Result<Self> {\n      let file = File::open(path).await?;\n      Ok(Self {\n        reader: BufReader::new(file),\n        chunk_size,\n      })\n    }\n  }\n  \n  #[async_trait]\n  impl AsyncChunkStream for ReadableChunkStream {\n    async fn next_chunk(&mut self) -> Option<Vec<u8>> {\n      let mut buffer = vec![0u8; self.chunk_size];\n      \n      match self.reader.read(&mut buffer).await {\n        Ok(0) => None, // EOF\n        Ok(n) => {\n          buffer.truncate(n);\n          Some(buffer)\n        }\n        Err(_) => None,\n      }\n    }\n  }\n  \n  pub async fn build_rdindex() -> Result<RDIndex, Box<dyn std::error::Error>> {\n    let config = RacDeltaConfig {\n      chunk_size: 1024 * 1024,\n      max_concurrency: Some(6),\n      storage: StorageConfig::SSH(SSHStorageConfig {\n        base: BaseStorageConfig {\n          path_prefix: Some("/root/upload".to_string()),\n        },\n        host: "localhost".to_string(),\n        port: Some(2222),\n        credentials: SSHCredentials {\n          username: "root".to_string(),\n          password: Some("password".to_string()),\n          private_key: None,\n        },\n      }),\n    };\n    \n    let client = RacDeltaClient::new(config).await?;\n    \n    let mut entries: Vec<FileEntry> = Vec::new();\n    \n    let dir = "my-dir";\n    let mut read_dir = tokio::fs::read_dir(dir).await?;\n    \n    while let Some(entry) = read_dir.next_entry().await? {\n      let path = entry.path();\n      \n      if !path.is_file() {\n        continue;\n      }\n      \n      let full_path_str = path.to_string_lossy().to_string();\n      \n      let mut stream = ReadableChunkStream::new(&full_path_str, 1024 * 1024).await?;\n      \n      let file_entry = client\n      .delta\n      .create_file_entry_from_stream(&mut stream, &full_path_str)\n      .await?;\n      \n      entries.push(file_entry);\n    }\n    \n    let rd_index = RDIndex {\n      version: 1,\n      created_at: chrono::Utc::now().timestamp_millis() as u64,\n      chunk_size: 1024 * 1024,\n      files: entries,\n    };\n    \n    Ok(rd_index)\n  }\n  '})]})]}),"\n",(0,t.jsx)(n.h2,{id:"servicio-de-reconstrucci\xf3n",children:"Servicio de reconstrucci\xf3n"}),"\n",(0,t.jsx)(n.p,{children:"El servicio de reconstrucci\xf3n es un servicio complejo que se encarga de reconstruir archivos a partir de chunks."}),"\n",(0,t.jsx)(n.p,{children:"Puede reconstruir un solo archivo o todos los archivos de un plan delta."}),"\n",(0,t.jsxs)(n.p,{children:["Para la reconstrucci\xf3n, el servicio utiliza un ",(0,t.jsx)(n.code,{children:"ChunkSource"}),", una clase especial que conecta directamente con tu adaptador de almacenamiento, tu memoria o tu disco, dependiendo de c\xf3mo quieras manejar los chunks."]}),"\n",(0,t.jsx)(n.p,{children:"Usa distintas estrategias de reconstrucci\xf3n, dependiendo en el tama\xf1o de archivo o del chunk source. Puedes especificar un umbral de tama\xf1o de archivo para reconstruir in-place o en temporal."}),"\n",(0,t.jsxs)(i.A,{children:[(0,t.jsxs)(o.A,{value:"node",label:"Node.js",children:[(0,t.jsx)("h4",{children:"Ejemplo de uso del servicio de reconstrucci\xf3n:"}),(0,t.jsx)(l.A,{className:"language-ts",children:"\n  const racDeltaClient = new RacDeltaClient({\n      chunkSize: 1024 * 1024,\n      maxConcurrency: 6,\n      storage: {\n          type: 'ssh',\n          host: 'localhost',\n          pathPrefix: '/root/upload',\n          port: 2222,\n          credentials: {\n              username: 'root',\n              password: 'password',\n          },\n      },\n  });\n\n  // Crea un Chunk Source usando nuestro almacenamiento actual (SSH en este caso)\n  const chunkSource = new StorageChunkSource(racDeltaClient.storage);\n\n  // Los chunk sources ofrecen un mont\xf3n de posibilidades, como reconstruir la mitad de los archivos v\xeda almacenamiento y la otra mitad v\xeda disco\n  // Pero en este caso lo reconstruiremos todo v\xeda almacenamiento\n  await racDeltaClient.reconstruction.reconstructFile(\n      remoteIndex.files[0],\n      'output-dir/file.txt',\n      chunkSource,\n      { inPlaceReconstructionThreshold: 0 } // No usamos in-place\n  );\n  "})]}),(0,t.jsxs)(o.A,{value:"rust",label:"Rust",children:[(0,t.jsx)("h4",{children:"Ejemplo de uso del servicio de reconstrucci\xf3n:"}),(0,t.jsx)(l.A,{className:"language-rust",children:'\n  let config = RacDeltaConfig {\n      chunk_size: 1024 * 1024,\n      max_concurrency: Some(6),\n      storage: StorageConfig::SSH(SSHStorageConfig {\n          base: BaseStorageConfig {\n              path_prefix: Some("/root/upload".to_string()),\n          },\n          host: "localhost".to_string(),\n          port: Some(2222),\n          credentials: SSHCredentials {\n              username: "root".to_string(),\n              password: Some("password".to_string()),\n              private_key: None,\n          },\n      }),\n  };\n\n  let client: RacDeltaClient = RacDeltaClient::new(config).await?;\n\n  let chunk_source: StorageChunkSource = StorageChunkSource::new(client.storage, None);\n\n  client\n      .reconstruction\n      .reconstruct_file(\n          remote_index.files[0],\n          Path::new("output-dir/file.txt"),\n          &chunk_source,\n          Some(&ReconstructionOptions {\n              in_place_reconstruction_threshold: Some(0),\n              ..Default::default()\n          }),\n          None,\n      )\n      .await?;\n  '})]})]}),"\n",(0,t.jsxs)(n.p,{children:["Para m\xe1s, echa un ojo a ",(0,t.jsx)(n.a,{href:"/core/services#reconstruction-service",children:"ReconstructionService"})]}),"\n",(0,t.jsx)(n.h3,{id:"streaming-1",children:"Streaming"}),"\n",(0,t.jsxs)(n.p,{children:["El servicio de reconstrucci\xf3n tambi\xe9n tiene soporte para reconstrucci\xf3n en streaming usando el m\xe9todo ",(0,t.jsx)(n.code,{children:"reconstructToStream"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"Esto devolver\xe1 un stream perfecto para reconstruir archivos hacia otra fuente, como subir a almacenamiento third party o para compresi\xf3n."}),"\n",(0,t.jsxs)(i.A,{children:[(0,t.jsxs)(o.A,{value:"node",label:"Node.js",children:[(0,t.jsx)("h4",{children:"Ejemplo de uso de stream de reconstrucci\xf3n:"}),(0,t.jsx)(l.A,{className:"language-ts",children:"\n  const racDeltaClient = new RacDeltaClient({\n  chunkSize: 1024 * 1024,\n  maxConcurrency: 6,\n  storage: {\n      type: 'ssh',\n      host: 'localhost',\n      pathPrefix: '/root/upload',\n      port: 2222,\n      credentials: {\n          username: 'root',\n          password: 'password',\n      },\n  },\n  });\n\n  // Crea un Chunk Source usando nuestro almacenamiento actual (SSH en este caso)\n  const chunkSource = new StorageChunkSource(racDeltaClient.storage);\n\n  const stream = await racDeltaClient.reconstruction.reconstructToStream(\n      remoteIndex.files[0],\n      chunkSource\n  );\n\n  // Subida de stream de ejemplo a S3\n  await s3.send(\n      new PutObjectCommand({\n          Bucket: 'my-bucket',\n          Key: 'files/file.txt',\n          Body: stream,\n      })\n  );\n  "})]}),(0,t.jsxs)(o.A,{value:"rust",label:"Rust",children:[(0,t.jsx)("h4",{children:"Ejemplo de uso de stream de reconstrucci\xf3n:"}),(0,t.jsx)(l.A,{className:"language-rust",children:'\n  let config = RacDeltaConfig {\n      chunk_size: 1024 * 1024,\n      max_concurrency: Some(6),\n      storage: StorageConfig::SSH(SSHStorageConfig {\n          base: BaseStorageConfig {\n              path_prefix: Some("/root/upload".to_string()),\n          },\n          host: "localhost".to_string(),\n          port: Some(2222),\n          credentials: SSHCredentials {\n              username: "root".to_string(),\n              password: Some("password".to_string()),\n              private_key: None,\n          },\n      }),\n  };\n\n  let client: RacDeltaClient = RacDeltaClient::new(config).await?;\n\n  let chunk_source: StorageChunkSource = StorageChunkSource::new(client.storage, None);\n\n  let stream: Pin<Box<dyn AsyncRead + Send + Sync>> = client\n      .reconstruction\n      .reconstruct_to_stream(remote_index.files[0], Arc::new(chunk_source))\n      .await?;\n\n  let byte_stream = ByteStream::from_reader(stream);\n\n  s3_client\n      .put_object()\n      .bucket("my-bucket")\n      .key("files/file.txt")\n      .body(byte_stream)\n      .send()\n      .await?;\n  '})]})]})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(m,{...e})}):m(e)}},9365:(e,n,a)=>{a.d(n,{A:()=>i});a(6540);var r=a(4164);const t={tabItem:"tabItem_Ymn6"};var s=a(4848);function i({children:e,hidden:n,className:a}){return(0,s.jsx)("div",{role:"tabpanel",className:(0,r.A)(t.tabItem,a),hidden:n,children:e})}}}]);