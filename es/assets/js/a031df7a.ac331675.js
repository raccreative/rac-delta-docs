"use strict";(globalThis.webpackChunkrac_delta_docs=globalThis.webpackChunkrac_delta_docs||[]).push([[1782],{565:(e,n,d)=>{d.r(n),d.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>l,metadata:()=>r,toc:()=>t});const r=JSON.parse('{"id":"reference/Rust/pipelines/hash-upload-pipeline","title":"HashUploadPipeline","description":"Adaptador abstracto de la pipeline de subida para acceder a chunks por hash para el flujo de subida.","source":"@site/i18n/es/docusaurus-plugin-content-docs/current/reference/Rust/pipelines/hash-upload-pipeline.md","sourceDirName":"reference/Rust/pipelines","slug":"/reference/Rust/pipelines/hash-upload-pipeline","permalink":"/rac-delta-docs/es/reference/Rust/pipelines/hash-upload-pipeline","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"HashUploadPipeline","description":"Adaptador abstracto de la pipeline de subida para acceder a chunks por hash para el flujo de subida.","sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Pipelines","permalink":"/rac-delta-docs/es/category/pipelines-1"},"next":{"title":"UrlUploadPipeline","permalink":"/rac-delta-docs/es/reference/Rust/pipelines/url-upload-pipeline"}}');var s=d(4848),i=d(8453);const l={title:"HashUploadPipeline",description:"Adaptador abstracto de la pipeline de subida para acceder a chunks por hash para el flujo de subida.",sidebar_position:1},c="HashUploadPipeline",o={},t=[{value:"Constructor",id:"constructor",level:2},{value:"M\xe9todos",id:"m\xe9todos",level:2},{value:"UploadOptions",id:"uploadoptions",level:2},{value:"PipelineError",id:"pipelineerror",level:2},{value:"Detalles de m\xe9todos",id:"detalles-de-m\xe9todos",level:2},{value:"<code>execute(directory, remote_index, options)</code>",id:"executedirectory-remote_index-options",level:3},{value:"<code>scan_directory(dir, ignore_patterns)</code>",id:"scan_directorydir-ignore_patterns",level:3},{value:"<code>upload_missing_chunks(plan, base_dir, force, options)</code>",id:"upload_missing_chunksplan-base_dir-force-options",level:3},{value:"<code>upload_index(index)</code>",id:"upload_indexindex",level:3},{value:"<code>delete_obsolete_chunks(plan, options)</code>",id:"delete_obsolete_chunksplan-options",level:3},{value:"<code>update_progress(value, phase, speed, options)</code>",id:"update_progressvalue-phase-speed-options",level:3},{value:"<code>change_state(state, options)</code>",id:"change_statestate-options",level:3},{value:"Relacionado",id:"relacionado",level:2}];function a(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"hashuploadpipeline",children:"HashUploadPipeline"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"HashUploadPipeline"})," es una clase abstracta dise\xf1ada para manejar subidas usando los adaptadores de almacenamiento basados en hash (",(0,s.jsx)(n.code,{children:"HashStorageAdapter"}),").\nOrquesta el proceso de escanear directorios, computar deltas con ",(0,s.jsx)(n.code,{children:"DeltaService"}),", subir chunks nuevos, y limpiar los chunks obsoletos."]}),"\n",(0,s.jsx)(n.p,{children:"Esta pipeline es com\xfanmente usada cuando las subidas son a sistemas de almacenamiento donde los chunks se identifican por su hash."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"constructor",children:"Constructor"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Par\xe1metro"}),(0,s.jsx)(n.th,{children:"Tipo"}),(0,s.jsx)(n.th,{children:"Descripci\xf3n"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"storage"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Arc<dyn HashStorageAdapter>"})}),(0,s.jsx)(n.td,{children:"Adaptador de almacenamiento basado en hash que se usar\xe1 (se crea autom\xe1ticamente con el cliente)."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"delta"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Arc<dyn DeltaService>"})}),(0,s.jsx)(n.td,{children:"DeltaService usado para generar \xedndices y compararlos."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"config"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Arc<RacDeltaConfig>"})}),(0,s.jsx)(n.td,{children:"Configuraci\xf3n base del cliente."})]})]})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"m\xe9todos",children:"M\xe9todos"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"M\xe9todo"}),(0,s.jsx)(n.th,{children:"Devuelve"}),(0,s.jsx)(n.th,{children:"Descripci\xf3n"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"execute(directory, remote_index, options)"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Result<RDIndex, PipelineError>"})}),(0,s.jsx)(n.td,{children:"Realiza un proceso de subida completo para un directorio."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"scan_directory(dir, ignore_patterns)"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Result<RDIndex, PipelineError>"})}),(0,s.jsx)(n.td,{children:"Escanea el directorio recursivamente y crea un RDIndex."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"upload_missing_chunks(plan, base_dir, force, options)"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Result<(), PipelineError>"})}),(0,s.jsx)(n.td,{children:"Sube solo los chunks faltantes o actualizados definidos en el DeltaPlan."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"upload_index(index)"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Result<(), PipelineError>"})}),(0,s.jsx)(n.td,{children:"Sube el archivo RDIndex al adaptador de almacenamiento."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"delete_obsolete_chunks(plan, options)"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Result<(), PipelineError>"})}),(0,s.jsx)(n.td,{children:"Elimina chunks obsoletos del almacenamiento especificados en el delta plan."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"update_progress(value, phase, speed, options)"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"()"})}),(0,s.jsx)(n.td,{children:"M\xe9todo opcional que llama a la callback de progreso en opciones."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"change_state(state, options)"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"()"})}),(0,s.jsx)(n.td,{children:"M\xe9todo opcional que llama a la callback change_state en opciones."})]})]})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"uploadoptions",children:"UploadOptions"}),"\n",(0,s.jsxs)(n.p,{children:["El objeto ",(0,s.jsx)(n.code,{children:"UploadOptions"})," permite personalizar el comportamiento de una subida:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"pub struct UploadOptions {\n    pub force: Option<bool>,\n    pub require_remote_index: Option<bool>,\n    pub ignore_patterns: Option<Vec<String>>,\n    pub on_progress: Option<Arc<dyn Fn(UploadPhase, f64, Option<f64>) + Send + Sync>>,\n    pub on_state_change: Option<Arc<dyn Fn(UploadState) + Send + Sync>>,\n}\n"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Propiedad"}),(0,s.jsx)(n.th,{children:"Tipo"}),(0,s.jsx)(n.th,{children:"Descripci\xf3n"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"force"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Option<bool>"})}),(0,s.jsx)(n.td,{children:"Si es true, fuerza una subida completa incluso si existe un \xedndice remoto. Si es false, solo los chunks nuevos y modificados se subir\xe1n."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"require_remote_index"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Option<bool>"})}),(0,s.jsx)(n.td,{children:"Si es true y no hay \xedndice remoto, se aborta la subida. Si es false (por defecto), sube todo si no encuentra \xedndice remoto."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ignore_patterns"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Option<Vec<String>>"})}),(0,s.jsx)(n.td,{children:"Archivos y directorios que deben ser ignorados al crear el rd-index.json."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"on_progress"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Option<Arc<dyn Fn(UploadPhase, f64, Option<f64>) + Send + Sync>>"})}),(0,s.jsx)(n.td,{children:"Callback opcional para informar progreso."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"on_state_change"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Option<Arc<dyn Fn(UploadState) + Send + Sync>>"})}),(0,s.jsx)(n.td,{children:"Callback opcional para informar cambios de estado."})]})]})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"pub enum UploadState {\n    Uploading,\n    Comparing,\n    Cleaning,\n    Finalizing,\n    Scanning,\n}\n\npub enum UploadPhase {\n    Upload,\n    Deleting,\n}\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"pipelineerror",children:"PipelineError"}),"\n",(0,s.jsxs)(n.p,{children:["Enum de errores personalizado para los resultados de HashUploadPipeline. (Usa ",(0,s.jsx)(n.code,{children:"thiserror"}),")"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'pub enum PipelineError {\n    #[error("I/O error: {0}")]\n    Io(#[from] std::io::Error),\n\n    #[error("Delta error: {0}")]\n    Delta(String),\n\n    #[error("Storage error: {0}")]\n    Storage(String),\n\n    #[error("Index error: {0}")]\n    Index(String),\n\n    #[error("Invalid argument: {0}")]\n    InvalidArgument(String),\n\n    #[error("Operation aborted")]\n    Aborted,\n\n    #[error("Other error: {0}")]\n    Other(String),\n}\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"detalles-de-m\xe9todos",children:"Detalles de m\xe9todos"}),"\n",(0,s.jsx)(n.h3,{id:"executedirectory-remote_index-options",children:(0,s.jsx)(n.code,{children:"execute(directory, remote_index, options)"})}),"\n",(0,s.jsxs)(n.p,{children:["Realiza un proceso de subida completo para un directorio. Devuelve el ",(0,s.jsx)(n.code,{children:"RDIndex"})," resultante tras el proceso."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Par\xe1metros"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Nombre"}),(0,s.jsx)(n.th,{children:"Tipo"}),(0,s.jsx)(n.th,{children:"Descripci\xf3n"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"directory"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"&Path"})}),(0,s.jsx)(n.td,{children:"Directorio que ser\xe1 comparado y subido."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"remote_index"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Option<RDIndex>"})}),(0,s.jsx)(n.td,{children:"rd-index remoto opcional. Si no se proporciona ninguno, se intentar\xe1 descargar del almacenamiento."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"options"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Option<UploadOptions>"})}),(0,s.jsx)(n.td,{children:"Opciones para el proceso de subida. Mira UploadOptions arriba."})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Devuelve"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"Result<RDIndex, PipelineError>"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"scan_directorydir-ignore_patterns",children:(0,s.jsx)(n.code,{children:"scan_directory(dir, ignore_patterns)"})}),"\n",(0,s.jsx)(n.p,{children:"Escanea el directorio recursivamente y crea un RDIndex, ignorando los archivos que coincidan con los patrones proporcionados."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Par\xe1metros"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Nombre"}),(0,s.jsx)(n.th,{children:"Tipo"}),(0,s.jsx)(n.th,{children:"Descripci\xf3n"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"dir"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"&Path"})}),(0,s.jsx)(n.td,{children:"Directorio a escanear."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ignorePatterns"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Option<Vec<String>>"})}),(0,s.jsx)(n.td,{children:"Patrones a ignorar opcionales, estos patrones se ignorar\xe1n al crear el RDIndex."})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Devuelve"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"Result<RDIndex, PipelineError>"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"upload_missing_chunksplan-base_dir-force-options",children:(0,s.jsx)(n.code,{children:"upload_missing_chunks(plan, base_dir, force, options)"})}),"\n",(0,s.jsx)(n.p,{children:"Sube solo los chunks que faltan o han sido actualizados definidos en el DeltaPlan."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Par\xe1metros"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Nombre"}),(0,s.jsx)(n.th,{children:"Tipo"}),(0,s.jsx)(n.th,{children:"Descripci\xf3n"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"plan"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"&DeltaPlan"})}),(0,s.jsx)(n.td,{children:"El plan delta indicando qu\xe9 chunks faltan."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"base_dir"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"&Path"})}),(0,s.jsx)(n.td,{children:"El directorio base que contiene los archivos locales."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"force"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"bool"})}),(0,s.jsx)(n.td,{children:"Si es true, forzar\xe1 la sobreescritura de chunks en el almacenamiento."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"options"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Option<UploadOptions>"})}),(0,s.jsx)(n.td,{children:"Opciones para el proceso de subida. Mira UploadOptions arriba."})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Devuelve"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"Result<(), PipelineError>"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"upload_indexindex",children:(0,s.jsx)(n.code,{children:"upload_index(index)"})}),"\n",(0,s.jsx)(n.p,{children:"Sube el archivo RDIndex al almacenamiento."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Par\xe1metros"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Nombre"}),(0,s.jsx)(n.th,{children:"Tipo"}),(0,s.jsx)(n.th,{children:"Descripci\xf3n"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"index"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"&RDIndex"})}),(0,s.jsx)(n.td,{children:"El objeto rd-index a subir."})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Devuelve"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"Result<(), PipelineError>"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"delete_obsolete_chunksplan-options",children:(0,s.jsx)(n.code,{children:"delete_obsolete_chunks(plan, options)"})}),"\n",(0,s.jsx)(n.p,{children:"Elimina los chunks obsoletos del almacenamiento especificados por el plan delta."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Par\xe1metros"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Nombre"}),(0,s.jsx)(n.th,{children:"Tipo"}),(0,s.jsx)(n.th,{children:"Descripci\xf3n"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"plan"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"&DeltaPlan"})}),(0,s.jsx)(n.td,{children:"El plan delta que indica los chunks obsoletos."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"options"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Option<UploadOptions>"})}),(0,s.jsx)(n.td,{children:"Opciones para el proceso de subida. Mira UploadOptions arriba."})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Devuelve"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"Result<(), PipelineError>"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"update_progressvalue-phase-speed-options",children:(0,s.jsx)(n.code,{children:"update_progress(value, phase, speed, options)"})}),"\n",(0,s.jsxs)(n.p,{children:["M\xe9todo que se usar\xe1 internamente para llamar a la callback dada ",(0,s.jsx)(n.code,{children:"on_progress"})," en opciones."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Par\xe1metros"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Nombre"}),(0,s.jsx)(n.th,{children:"Tipo"}),(0,s.jsx)(n.th,{children:"Descripci\xf3n"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"value"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"f64"})}),(0,s.jsx)(n.td,{children:"Valor del progreso."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"phase"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"UploadPhase"})}),(0,s.jsx)(n.td,{children:"Fase de subida actual (uploading o deleting)."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"speed"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Option<f64>"})}),(0,s.jsx)(n.td,{children:"Velocidad en bytes/s para el proceso de subida."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"options"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Option<&UploadOptions>"})}),(0,s.jsxs)(n.td,{children:["Opciones que debe incluir la callback ",(0,s.jsx)(n.code,{children:"on_progress"}),"."]})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Devuelve"})," ",(0,s.jsx)(n.code,{children:"()"})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"change_statestate-options",children:(0,s.jsx)(n.code,{children:"change_state(state, options)"})}),"\n",(0,s.jsxs)(n.p,{children:["M\xe9todo que se usar\xe1 internamente para llamar a la callback dada ",(0,s.jsx)(n.code,{children:"on_state_change"})," en opciones."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Par\xe1metros"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Nombre"}),(0,s.jsx)(n.th,{children:"Tipo"}),(0,s.jsx)(n.th,{children:"Descripci\xf3n"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"state"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"UploadState"})}),(0,s.jsx)(n.td,{children:"Estado actual del progreso."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"options"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Option<&UploadOptions>"})}),(0,s.jsxs)(n.td,{children:["Opciones que debe incluir la callback ",(0,s.jsx)(n.code,{children:"on_state_change"}),"."]})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Devuelve"})," ",(0,s.jsx)(n.code,{children:"()"})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"relacionado",children:"Relacionado"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/reference/Rust/pipelines/url-upload-pipeline",children:"UrlUploadPipeline"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/reference/Rust/models/rdindex",children:"RDIndex"})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}},8453:(e,n,d)=>{d.d(n,{R:()=>l,x:()=>c});var r=d(6540);const s={},i=r.createContext(s);function l(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);