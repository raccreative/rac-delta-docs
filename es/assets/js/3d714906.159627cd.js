"use strict";(globalThis.webpackChunkrac_delta_docs=globalThis.webpackChunkrac_delta_docs||[]).push([[6421],{1470:(e,n,s)=>{s.d(n,{A:()=>S});var r=s(6540),a=s(4164),i=s(7559),o=s(3104),t=s(6347),l=s(205),d=s(7485),c=s(1682),u=s(679);function p(e){return r.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}function h(e){const{values:n,children:s}=e;return(0,r.useMemo)(()=>{const e=n??function(e){return p(e).map(({props:{value:e,label:n,attributes:s,default:r}})=>({value:e,label:n,attributes:s,default:r}))}(s);return function(e){const n=(0,c.XI)(e,(e,n)=>e.value===n.value);if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map(e=>e.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e},[n,s])}function x({value:e,tabValues:n}){return n.some(n=>n.value===e)}function m({queryString:e=!1,groupId:n}){const s=(0,t.W6)(),a=function({queryString:e=!1,groupId:n}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,d.aZ)(a),(0,r.useCallback)(e=>{if(!a)return;const n=new URLSearchParams(s.location.search);n.set(a,e),s.replace({...s.location,search:n.toString()})},[a,s])]}function j(e){const{defaultValue:n,queryString:s=!1,groupId:a}=e,i=h(e),[o,t]=(0,r.useState)(()=>function({defaultValue:e,tabValues:n}){if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!x({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map(e=>e.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const s=n.find(e=>e.default)??n[0];if(!s)throw new Error("Unexpected error: 0 tabValues");return s.value}({defaultValue:n,tabValues:i})),[d,c]=m({queryString:s,groupId:a}),[p,j]=function({groupId:e}){const n=function(e){return e?`docusaurus.tab.${e}`:null}(e),[s,a]=(0,u.Dv)(n);return[s,(0,r.useCallback)(e=>{n&&a.set(e)},[n,a])]}({groupId:a}),b=(()=>{const e=d??p;return x({value:e,tabValues:i})?e:null})();(0,l.A)(()=>{b&&t(b)},[b]);return{selectedValue:o,selectValue:(0,r.useCallback)(e=>{if(!x({value:e,tabValues:i}))throw new Error(`Can't select invalid tab value=${e}`);t(e),c(e),j(e)},[c,j,i]),tabValues:i}}var b=s(2303);const g={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var f=s(4848);function v({className:e,block:n,selectedValue:s,selectValue:r,tabValues:i}){const t=[],{blockElementScrollPositionUntilNextRender:l}=(0,o.a_)(),d=e=>{const n=e.currentTarget,a=t.indexOf(n),o=i[a].value;o!==s&&(l(n),r(o))},c=e=>{let n=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const s=t.indexOf(e.currentTarget)+1;n=t[s]??t[0];break}case"ArrowLeft":{const s=t.indexOf(e.currentTarget)-1;n=t[s]??t[t.length-1];break}}n?.focus()};return(0,f.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,a.A)("tabs",{"tabs--block":n},e),children:i.map(({value:e,label:n,attributes:r})=>(0,f.jsx)("li",{role:"tab",tabIndex:s===e?0:-1,"aria-selected":s===e,ref:e=>{t.push(e)},onKeyDown:c,onClick:d,...r,className:(0,a.A)("tabs__item",g.tabItem,r?.className,{"tabs__item--active":s===e}),children:n??e},e))})}function y({lazy:e,children:n,selectedValue:s}){const i=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const e=i.find(e=>e.props.value===s);return e?(0,r.cloneElement)(e,{className:(0,a.A)("margin-top--md",e.props.className)}):null}return(0,f.jsx)("div",{className:"margin-top--md",children:i.map((e,n)=>(0,r.cloneElement)(e,{key:n,hidden:e.props.value!==s}))})}function _(e){const n=j(e);return(0,f.jsxs)("div",{className:(0,a.A)(i.G.tabs.container,"tabs-container",g.tabList),children:[(0,f.jsx)(v,{...n,...e}),(0,f.jsx)(y,{...n,...e})]})}function S(e){const n=(0,b.A)();return(0,f.jsx)(_,{...e,children:p(e.children)},String(n))}},2854:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>u,contentTitle:()=>c,default:()=>x,frontMatter:()=>d,metadata:()=>r,toc:()=>p});const r=JSON.parse('{"id":"usage/uploading","title":"Subidas","description":"Una de las operaciones principales de rac-delta es la subida de nuevas versiones de tus builds o directorios, y aplicar solo los chunks modificados o eliminar chunks obsoletos desde el almacenamiento remoto.","source":"@site/i18n/es/docusaurus-plugin-content-docs/current/usage/uploading.mdx","sourceDirName":"usage","slug":"/usage/uploading","permalink":"/rac-delta-docs/es/usage/uploading","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Cliente","permalink":"/rac-delta-docs/es/usage/client"},"next":{"title":"Descargas","permalink":"/rac-delta-docs/es/usage/downloading"}}');var a=s(4848),i=s(8453),o=s(1470),t=s(9365),l=s(3457);const d={sidebar_position:2},c="Subidas",u={},p=[{value:"Pipeline de subida",id:"pipeline-de-subida",level:2},{value:"M\xe9todos auxiliares de la pipeline",id:"m\xe9todos-auxiliares-de-la-pipeline",level:2}];function h(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"subidas",children:"Subidas"})}),"\n",(0,a.jsx)(n.p,{children:"Una de las operaciones principales de rac-delta es la subida de nuevas versiones de tus builds o directorios, y aplicar solo los chunks modificados o eliminar chunks obsoletos desde el almacenamiento remoto."}),"\n",(0,a.jsx)(n.p,{children:"Puedes usar rac-delta para actualizar una build o para subir una build completamente nueva a tu almacenamiento."}),"\n",(0,a.jsx)(n.h2,{id:"pipeline-de-subida",children:"Pipeline de subida"}),"\n",(0,a.jsx)(n.p,{children:"Para esto, el SDK de rac-delta proporciona una pipeline de subida que ya implementa todos los pasos para subir autom\xe1ticamente nuevas builds a tu almacenamiento."}),"\n",(0,a.jsxs)(o.A,{children:[(0,a.jsxs)(t.A,{value:"node",label:"Node.js",children:[(0,a.jsx)("h4",{children:"Uso b\xe1sico de la pipeline:"}),(0,a.jsx)(l.A,{className:"language-ts",children:"\n  const remoteIndexToUse = undefined;\n\n  await racDeltaClient.pipelines.upload.execute('path/to/build', remoteIndexToUse, {\n      requireRemoteIndex: false,\n      force: false,\n      ignorePatterns: undefined,\n      onStateChange: (state) => {\n          console.log(state);\n      },\n      onProgress: (type, progress, speed) => {\n          console.log(type, progress.toFixed(1), speed?.toFixed(1));\n      },\n  });\n  "}),(0,a.jsx)("h4",{children:"Par\xe1metros:"}),(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"Nombre"}),(0,a.jsx)(n.th,{children:"Tipo"}),(0,a.jsx)(n.th,{children:"Descripci\xf3n"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"ruta"}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"string"})}),(0,a.jsx)(n.td,{children:"La ruta a tu build local que ser\xe1 subida (ruta relativa o absoluta)"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"rd-index remoto"}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"RDIndex"})}),(0,a.jsx)(n.td,{children:"El rd-index.json como objeto RDIndex que ser\xe1 usado como \xedndice remoto, si no se proporciona ninguno, la pipeline intentar\xe1 descargarlo desdde el almacenamiento."})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"opciones de subida"}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"UploadOptions"})}),(0,a.jsx)(n.td,{children:(0,a.jsxs)("table",{children:[" ",(0,a.jsxs)("thead",{children:[" ",(0,a.jsxs)("tr",{children:[" ",(0,a.jsx)("th",{children:"Par\xe1metro"})," ",(0,a.jsx)("th",{children:"Tipo"})," ",(0,a.jsx)("th",{children:"Descripci\xf3n"})," "]})," "]})," ",(0,a.jsxs)("tbody",{children:[" ",(0,a.jsxs)("tr",{children:[" ",(0,a.jsx)("td",{children:"requireRemoteIndex"})," ",(0,a.jsx)("td",{children:(0,a.jsx)("code",{children:"boolean"})})," ",(0,a.jsx)("td",{children:"Si es false, no lanzar\xe1 error si no se encuentra \xedndice remoto y subir\xe1 todo."})," "]})," ",(0,a.jsxs)("tr",{children:[" ",(0,a.jsx)("td",{children:"force"})," ",(0,a.jsx)("td",{children:(0,a.jsx)("code",{children:"boolean"})})," ",(0,a.jsx)("td",{children:"Si es true, subir\xe1 todo excepto los patrones ignorados"})," "]})," ",(0,a.jsxs)("tr",{children:[" ",(0,a.jsx)("td",{children:"ignorePatterns"})," ",(0,a.jsx)("td",{children:(0,a.jsx)("code",{children:"string[]"})})," ",(0,a.jsx)("td",{children:"Archivos o directorios a ignorar en la generaci\xf3n del rd-index.json. Ejemplo: '*.zip' o 'dir/**'"})," "]})," ",(0,a.jsxs)("tr",{children:[" ",(0,a.jsx)("td",{children:"onStateChange"}),(0,a.jsx)("td",{children:(0,a.jsx)("code",{children:"(state: UploadState) => void"})})," ",(0,a.jsxs)("td",{children:["Callback que notificar\xe1 cuando la pipeline cambia de estado. Los estados disponibles son: ",(0,a.jsx)(n.strong,{children:"uploading"}),", ",(0,a.jsx)(n.strong,{children:"comparing"}),", ",(0,a.jsx)(n.strong,{children:"cleaning"}),", ",(0,a.jsx)(n.strong,{children:"scanning"})," y ",(0,a.jsx)(n.strong,{children:"finalizing"})]})," "]})," ",(0,a.jsxs)("tr",{children:[(0,a.jsx)("td",{children:"onProgress"}),(0,a.jsx)("td",{children:(0,a.jsx)("code",{children:'(type: "upload" | "deleting", progress: number, speed?: number'})}),(0,a.jsx)("td",{children:"Callback que notificar\xe1 el progreso de las operaciones de subida. Notificar\xe1 el progreso de subida y velocidad de red, y el progreso de eliminaci\xf3n de chunks remotos."})]})," "]})," "]})})]})]})]})]}),(0,a.jsxs)(t.A,{value:"rust",label:"Rust",children:[(0,a.jsx)("h4",{children:"Uso b\xe1sico de la pipeline:"}),(0,a.jsx)(l.A,{className:"language-rust",children:'\n  let remote_index_to_use: Option<RDIndex> = None;\n\n  match client.pipelines.upload {\n      UploadPipelineBundle::Hash(pipeline) => {\n          pipeline\n              .execute(\n                  Path::new("my/dir"),\n                  remote_index_to_use,\n                  Some(UploadOptions {\n                      require_remote_index: Some(false),\n                      force: Some(false),\n                      ignore_patterns: None,\n                      on_state_change: Some(std::sync::Arc::new(|state| {\n                          println!("Upload state: {:?}", state);\n                      })),\n                      on_progress: Some(std::sync::Arc::new(|phase, progress, speed| {\n                          println!(\n                              "Phase: {:?}, progress: {:.1}%, speed: {}",\n                              phase,\n                              progress * 100.0,\n                              speed\n                                  .map_or("unknown".to_string(), |s| format!("{:.1} bytes/s", s))\n                          );\n                      })),\n                  }),\n              )\n              .await?;\n      }\n      UploadPipelineBundle::Url(_p) => {\n          // nada para SSH\n      }\n  }\n  '}),(0,a.jsx)("h4",{children:"Par\xe1metros:"}),(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"Nombre"}),(0,a.jsx)(n.th,{children:"Tipo"}),(0,a.jsx)(n.th,{children:"Descripci\xf3n"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"ruta"}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"Path"})}),(0,a.jsx)(n.td,{children:"La ruta a tu build local que ser\xe1 subida (ruta relativa o absoluta)"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"rd-index remoto"}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"Option<RDIndex>"})}),(0,a.jsx)(n.td,{children:"El rd-index.json como objeto RDIndex que ser\xe1 usado como \xedndice remoto, si no se proporciona ninguno, la pipeline intentar\xe1 descargarlo desdde el almacenamiento."})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"opciones de subida"}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"Option<UploadOptions>"})}),(0,a.jsx)(n.td,{children:(0,a.jsxs)("table",{children:[" ",(0,a.jsxs)("thead",{children:[" ",(0,a.jsxs)("tr",{children:[" ",(0,a.jsx)("th",{children:"Par\xe1metro"})," ",(0,a.jsx)("th",{children:"Tipo"})," ",(0,a.jsx)("th",{children:"Descripci\xf3n"})," "]})," "]})," ",(0,a.jsxs)("tbody",{children:[" ",(0,a.jsxs)("tr",{children:[" ",(0,a.jsx)("td",{children:"require_remote_index"})," ",(0,a.jsx)("td",{children:(0,a.jsx)("code",{children:"Option<bool>"})})," ",(0,a.jsx)("td",{children:"Si es false, no lanzar\xe1 error si no se encuentra \xedndice remoto y subir\xe1 todo."})," "]})," ",(0,a.jsxs)("tr",{children:[" ",(0,a.jsx)("td",{children:"force"})," ",(0,a.jsx)("td",{children:(0,a.jsx)("code",{children:"Option<bool>"})})," ",(0,a.jsx)("td",{children:"Si es true, subir\xe1 todo excepto los patrones ignorados"})," "]})," ",(0,a.jsxs)("tr",{children:[" ",(0,a.jsx)("td",{children:"ignore_patterns"})," ",(0,a.jsx)("td",{children:(0,a.jsx)("code",{children:"Option<Vec<String, Global>>"})})," ",(0,a.jsx)("td",{children:"Archivos o directorios a ignorar en la generaci\xf3n del rd-index.json. Ejemplo: '*.zip' o 'dir/**'"})," "]})," ",(0,a.jsxs)("tr",{children:[" ",(0,a.jsx)("td",{children:"on_state_change"}),(0,a.jsx)("td",{children:(0,a.jsx)("code",{children:"Option<Arc<dyn Fn(UploadState) + Send + Sync + 'static, Global>>"})})," ",(0,a.jsxs)("td",{children:["Callback que notificar\xe1 cuando la pipeline cambia de estado. Los estados disponibles son: ",(0,a.jsx)(n.strong,{children:"uploading"}),", ",(0,a.jsx)(n.strong,{children:"comparing"}),", ",(0,a.jsx)(n.strong,{children:"cleaning"}),", ",(0,a.jsx)(n.strong,{children:"scanning"})," y ",(0,a.jsx)(n.strong,{children:"finalizing"})]})," "]})," ",(0,a.jsxs)("tr",{children:[(0,a.jsx)("td",{children:"on_progress"}),(0,a.jsx)("td",{children:(0,a.jsx)("code",{children:"Option<Arc<dyn Fn(UploadPhase, f64, Option<f64>) + Send + Sync + 'static, Global>>"})}),(0,a.jsx)("td",{children:"Callback que notificar\xe1 el progreso de las operaciones de subida. Notificar\xe1 el progreso de subida y velocidad de red, y el progreso de eliminaci\xf3n de chunks remotos."})]})," "]})," "]})})]})]})]})]})]}),"\n",(0,a.jsx)(n.p,{children:"Esto generar\xe1 autom\xe1ticamente tu rd-index.json local, descargar\xe1 el rd-index.json remoto si no se ha proporcionado ninguno, comparar\xe1 ambos \xedndices, generar\xe1 el Delta Plan y subir\xe1 y limpiar\xe1 los nuevos chunks a tu almacenamiento configurado en el cliente de rac-delta."}),"\n",(0,a.jsx)(n.h2,{id:"m\xe9todos-auxiliares-de-la-pipeline",children:"M\xe9todos auxiliares de la pipeline"}),"\n",(0,a.jsx)(n.p,{children:"Para poder subir correctamente los directorios usando rac-delta, la pipeline de subida usa m\xe9todos internos que usan los servicios de rac-delta para subir, comparar \xedndices, eliminar chunks obsoletos, etc..."}),"\n",(0,a.jsx)(n.p,{children:"Si no quieres usar el m\xe9todo execute por defecto, puedes crear tu propia pipeline usando estos m\xe9todos auxiliares y los servicios."}),"\n",(0,a.jsxs)(o.A,{children:[(0,a.jsxs)(t.A,{value:"node",label:"Node.js",children:[(0,a.jsx)("h4",{children:"Ejemplo de uso de los m\xe9todos auxiliares de pipeline de subida:"}),(0,a.jsx)(l.A,{className:"language-ts",children:"\n  const racDeltaClient = new RacDeltaClient({\n  chunkSize: 1024 * 1024,\n  maxConcurrency: 6,\n  storage: {\n      type: 'ssh',\n      host: 'localhost',\n      pathPrefix: '/root/upload',\n      port: 2222,\n      credentials: {\n      username: 'root',\n      password: 'password',\n      },\n  },\n  });\n\n  const remoteIndex = fetch('my/api/or/my/storage/rd-index.json');\n\n  // Generamos el rd-index.json local (podr\xedas usar racDeltaClient.delta.createIndexFromDirectory tambi\xe9n)\n  const localIndex = await racDeltaClient.pipelines.upload.scanDirectory('my/build');\n\n  // Generamos el DeltaPlan comparando ambos \xedndices\n  const deltaPlan = await racDeltaClient.delta.compareForUpload(localIndex, remoteIndex);\n\n  // Subimos los nuevos chunks (usa maxConcurrency del cliente)\n  await racDeltaClient.pipelines.upload.uploadMissingChunks(deltaPlan, 'my/build', false);\n\n  // ... Borrar chunks obsoletos, subir nuevo \xedndice... etc\n\n"})]}),(0,a.jsxs)(t.A,{value:"rust",label:"Rust",children:[(0,a.jsx)("h4",{children:"Ejemplo de uso de los m\xe9todos auxiliares de pipeline de subida:"}),(0,a.jsx)(l.A,{className:"language-rust",children:'\n  let config = RacDeltaConfig {\n      chunk_size: 1024 * 1024,\n      max_concurrency: Some(6),\n      storage: StorageConfig::SSH(SSHStorageConfig {\n          base: BaseStorageConfig {\n              path_prefix: Some("/root/upload".to_string()),\n          },\n          host: "localhost".to_string(),\n          port: Some(2222),\n          credentials: SSHCredentials {\n              username: "root".to_string(),\n              password: Some("password".to_string()),\n              private_key: None,\n          },\n      }),\n  };\n\n  let client: RacDeltaClient = RacDeltaClient::new(config).await?;\n\n  let remote_index = fetch from remote...;\n\n  // Generamos el rd-index.json local (podr\xedas usar client.delta.create_index_from_directory tambi\xe9n)\n  let local_index: Option<RDIndex> = match client.pipelines.upload {\n      UploadPipelineBundle::Hash(ref pipeline) => {\n          Some(pipeline.scan_directory(Path::new("my/dir"), None).await?)\n      }\n      UploadPipelineBundle::Url(ref _p) => None,\n  };\n\n  // Generamos el DeltaPlan comparando ambos \xedndices\n  let delta_plan: DeltaPlan = client\n      .delta\n      .compare_for_upload(&local_index.unwrap(), remote_index)\n      .await?;\n\n  // Subimos los nuevos chunks (usa maxConcurrency del cliente)\n  match client.pipelines.upload {\n      UploadPipelineBundle::Hash(ref pipeline) => {\n          pipeline\n              .upload_missing_chunks(&delta_plan, Path::new("my/dir"), false, None)\n              .await?\n      }\n      UploadPipelineBundle::Url(ref _p) => (),\n  };\n\n  // ... Borrar chunks obsoletos, subir nuevo \xedndice... etc\n  '}),(0,a.jsx)(n.p,{children:"En Rust, las pipelines siempre est\xe1n divididas en Hash y Url, esto es as\xed porque UrlPipeline execute difiere de HashPipeline, haciendo un Enum resuelve esto parcialmente, \xa1pero el proyecto est\xe1 abierto a mejoras!"}),(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Nota"}),": Para casi todos los casos usar\xe1s la pipeline Hash, Url es solo para el tipo de almacenamiento URL."]})]})]}),"\n",(0,a.jsxs)(n.p,{children:["Para una lista completa de los m\xe9todos auxiliares echa un ojo a: ",(0,a.jsx)(n.a,{href:"/core/pipelines",children:"pipelines"}),".\nY tambi\xe9n a ",(0,a.jsx)(n.a,{href:"/core/interfaces#DeltaPlan",children:"DeltaPlan"})]})]})}function x(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},9365:(e,n,s)=>{s.d(n,{A:()=>o});s(6540);var r=s(4164);const a={tabItem:"tabItem_Ymn6"};var i=s(4848);function o({children:e,hidden:n,className:s}){return(0,i.jsx)("div",{role:"tabpanel",className:(0,r.A)(a.tabItem,s),hidden:n,children:e})}}}]);