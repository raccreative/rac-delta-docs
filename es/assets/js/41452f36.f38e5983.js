"use strict";(globalThis.webpackChunkrac_delta_docs=globalThis.webpackChunkrac_delta_docs||[]).push([[8340],{2463:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>t,contentTitle:()=>a,default:()=>u,frontMatter:()=>c,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"core/services","title":"Servicios","description":"Para poder organizar y usar rac-delta correctamente, es importante atomizar las responsabilidades del protocolo en distintos servicios.","source":"@site/i18n/es/docusaurus-plugin-content-docs/current/core/services.md","sourceDirName":"core","slug":"/core/services","permalink":"/rac-delta-docs/es/core/services","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"Adaptador de almacenamiento","permalink":"/rac-delta-docs/es/core/storage-adapter"},"next":{"title":"Pipelines","permalink":"/rac-delta-docs/es/core/pipelines"}}');var i=r(4848),o=r(8453);const c={sidebar_position:5},a="Servicios",t={},l=[{value:"Servicio hasher",id:"servicio-hasher",level:2},{value:"Servicio de validaci\xf3n",id:"servicio-de-validaci\xf3n",level:2},{value:"Servicio delta",id:"servicio-delta",level:2},{value:"AsyncChunkStream",id:"asyncchunkstream",level:3},{value:"Servicio de reconstrucci\xf3n",id:"servicio-de-reconstrucci\xf3n",level:2},{value:"ChunkSource",id:"chunksource",level:3},{value:"ReconstructionOptions",id:"reconstructionoptions",level:3},{value:"<code>forceRebuild</code>",id:"forcerebuild",level:4},{value:"<code>verifyAfterRebuild</code>",id:"verifyafterrebuild",level:4},{value:"<code>inPlaceReconstructionThreshold</code>",id:"inplacereconstructionthreshold",level:4},{value:"<code>fileConcurrency</code>",id:"fileconcurrency",level:4},{value:"<code>onProgress</code>",id:"onprogress",level:4}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"servicios",children:"Servicios"})}),"\n",(0,i.jsx)(n.p,{children:"Para poder organizar y usar rac-delta correctamente, es importante atomizar las responsabilidades del protocolo en distintos servicios."}),"\n",(0,i.jsx)(n.p,{children:"El core de rac-delta se compone de cuatro servicios principales que conectar\xe1n cada operaci\xf3n del protocolo."}),"\n",(0,i.jsx)(n.h2,{id:"servicio-hasher",children:"Servicio hasher"}),"\n",(0,i.jsxs)(n.p,{children:["Este servicio se encargar\xe1 de implementar el hashing para crear los hashes de los archivos y los chunks, para verificar la integraci\xf3n y para generar los objetos ",(0,i.jsx)(n.code,{children:"FileEntry"})," y ",(0,i.jsx)(n.code,{children:"Chunk"})," con sus hashes."]}),"\n",(0,i.jsx)(n.p,{children:"Aqu\xed est\xe1 la abstracci\xf3n del servicio, lista para ser implementada con la librer\xeda que prefieras."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:'title="Servicio hasher abstracto en TypeScript"',children:"interface StreamingHasher {\n  update(data: Uint8Array | Buffer): void;\n  digest(encoding?: 'hex'): string;\n}\n\ninterface HasherService {\n  hashFile(filePath: string, rootDir: string, chunkSize: number): Promise<FileEntry>;\n\n  hashStream(stream: AsyncChunkStream, onChunk?: (chunk: Uint8Array) => void): Promise<Chunk[]>;\n\n  hashBuffer(data: Uint8Array): Promise<string>;\n\n  verifyChunk(data: Uint8Array, expectedHash: string): Promise<boolean>;\n\n  verifyFile(path: string, expectedHash: string): Promise<boolean>;\n\n  createStreamingHasher(): Promise<StreamingHasher>;\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"servicio-de-validaci\xf3n",children:"Servicio de validaci\xf3n"}),"\n",(0,i.jsx)(n.p,{children:"El servicio de validaci\xf3n se usa \xfanicamente para validar archivos e \xedndices. Usa el servicio hasher internamente para esto. Tiene m\xe9todos b\xe1sicos que devuelven booleanos."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:'title="Servicio de validaci\xf3n abstracto en TypeScript"',children:"interface ValidationService {\n  validateFile(entry: FileEntry, path: string): Promise<boolean>;\n\n  validateIndex(index: RDIndex, basePath: string): Promise<boolean>;\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"servicio-delta",children:"Servicio delta"}),"\n",(0,i.jsx)(n.p,{children:"El servicio delta se encarga principalmente de crear los rd-index.json, compararlos y fusionarlos."}),"\n",(0,i.jsxs)(n.p,{children:["Comparar dos archivos rd-index generar\xe1n un ",(0,i.jsx)(n.a,{href:"/core/interfaces#deltaplan",children:"Delta Plan"})," que incluye los cambios a subir o descargar."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:'title="Servicio delta abstracto en TypeScript"',children:"interface DeltaService {\n  createIndexFromDirectory(\n    rootPath: string,\n    chunkSize: number,\n    concurrency?: number,\n    ignorePatterns?: string[]\n  ): Promise<RDIndex>;\n\n  createFileEntryFromStream(stream: AsyncChunkStream, path: string): Promise<FileEntry>;\n\n  compare(source: RDIndex, target: RDIndex | null): DeltaPlan;\n\n  mergePlans(base: DeltaPlan, updates: DeltaPlan): DeltaPlan;\n\n  compareForUpload(localIndex: RDIndex, remoteIndex: RDIndex | null): Promise<DeltaPlan>;\n\n  compareForDownload(localIndex: RDIndex | null, remoteIndex: RDIndex): Promise<DeltaPlan>;\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"asyncchunkstream",children:"AsyncChunkStream"}),"\n",(0,i.jsxs)(n.p,{children:["Como puedes ver arriba, ",(0,i.jsx)(n.code,{children:"createFileEntryFromStream"})," usa ",(0,i.jsx)(n.code,{children:"AsyncChunkStream"}),", un objeto que extiende AsyncIterable para una experiencia m\xe1s personalizada:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"interface AsyncChunkStream extends AsyncIterable<Uint8Array> {\n  nextChunk(): Promise<Uint8Array | null>;\n  reset?(): Promise<void>;\n  close?(): Promise<void>;\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Por c\xf3mo los streams se manejan de forma diferente en cada lenguaje, toma esto solo como recomendaci\xf3n y guia, puede diferir bastante de otros lenguajes como Python o Rust."}),"\n",(0,i.jsx)(n.h2,{id:"servicio-de-reconstrucci\xf3n",children:"Servicio de reconstrucci\xf3n"}),"\n",(0,i.jsx)(n.p,{children:"El servicio de reconstrucci\xf3n es un servicio complejo que se encarga de reconstruir los archivos a partir de los chunks."}),"\n",(0,i.jsx)(n.p,{children:"Puede reconstruir un solo archivo o todos los archivos de un delta plan."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:'title="Abstracci\xf3n de ejemplo del servicio de reconstrucci\xf3n en TypeScript"',children:"interface ReconstructionService {\n  reconstructFile(\n    entry: FileEntry,\n    outputPath: string,\n    chunkSource: ChunkSource,\n    options?: ReconstructionOptions\n  ): Promise<void>;\n\n  reconstructAll(\n    plan: DeltaPlan,\n    outputDir: string,\n    chunkSource: ChunkSource,\n    options?: ReconstructionOptions\n  ): Promise<void>;\n\n  reconstructToStream(entry: FileEntry, chunkSource: ChunkSource): Promise<Readable>;\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Solo tiene tres m\xe9todos p\xfablicos, pero tendr\xe1 tantos m\xe9todos privados como quieras hacer de complejo el servicio. (Reconstrucci\xf3n temporal, in-place, umbrales, validaci\xf3n, streaming...)"}),"\n",(0,i.jsx)(n.h3,{id:"chunksource",children:"ChunkSource"}),"\n",(0,i.jsxs)(n.p,{children:["Como puedes ver arriba, cada m\xe9todo necesita un ",(0,i.jsx)(n.code,{children:"ChunkSource"}),", un servicio especial que conecta directamente con tu adaptador de almacenamiento, tu memoria, o tu disco, dependiendo de c\xf3mo quieras manejar tus hcunks."]}),"\n",(0,i.jsxs)(n.p,{children:["Esta es la abstracci\xf3n para ",(0,i.jsx)(n.code,{children:"ChunkSource"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:'title="Abstracci\xf3n de ChunkSource en TypeScript"',children:"interface ChunkSource {\n  getChunk(hash: string): Promise<Buffer>;\n\n  getChunks?(hashes: string[], options?: { concurrency?: number }): Promise<Map<string, Buffer>>;\n\n  streamChunks?(\n    hashes: string[],\n    options?: { concurrency?: number; preserveOrder?: boolean }\n  ): AsyncGenerator<{ hash: string; data: Readable }>;\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Las implementaciones recomendadas son: ",(0,i.jsx)(n.code,{children:"StorageChunkSource"}),", ",(0,i.jsx)(n.code,{children:"MemoryChunkSource"})," y ",(0,i.jsx)(n.code,{children:"DiskChunkSource"})," (La primera descargar\xe1 los chunks desde el almacenamiento remoto, la segunda desde memoria si los chunks se descargaron primero, y la tercera lo mismo perdo desde el disco)"]}),"\n",(0,i.jsxs)(n.p,{children:["El uso recomendado para el servicio de reconstruccion es intentar ",(0,i.jsx)(n.code,{children:"streamChunks"})," > ",(0,i.jsx)(n.code,{children:"getChunks"})," > ",(0,i.jsx)(n.code,{children:"getChunk"})," si existen, para mejor rendimiento."]}),"\n",(0,i.jsx)(n.h3,{id:"reconstructionoptions",children:"ReconstructionOptions"}),"\n",(0,i.jsx)(n.p,{children:"Para una mejor experiencia de usuario, personalizaci\xf3n y rendimiento, hay algunos par\xe1metros de configuraci\xf3n recomendados para el servicio:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"interface ReconstructionOptions {\n  forceRebuild?: boolean;\n  verifyAfterRebuild?: boolean;\n  inPlaceReconstructionThreshold?: number;\n  fileConcurrency?: number;\n  onProgress?: (\n    reconstructProgress: number,\n    diskSpeed: number,\n    networkProgress?: number,\n    networkSpeed?: number\n  ) => void;\n}\n"})}),"\n",(0,i.jsx)(n.h4,{id:"forcerebuild",children:(0,i.jsx)(n.code,{children:"forceRebuild"})}),"\n",(0,i.jsxs)(n.p,{children:["Fuerza la reconstrucci\xf3n incluso si el hash del archivo coincide. (",(0,i.jsx)(n.code,{children:"boolean"}),")"]}),"\n",(0,i.jsx)(n.h4,{id:"verifyafterrebuild",children:(0,i.jsx)(n.code,{children:"verifyAfterRebuild"})}),"\n",(0,i.jsxs)(n.p,{children:["Verifica el hash del archivo reconstruido tras terminar. Si no coincide, se lanza un error. (",(0,i.jsx)(n.code,{children:"boolean"}),")"]}),"\n",(0,i.jsx)(n.h4,{id:"inplacereconstructionthreshold",children:(0,i.jsx)(n.code,{children:"inPlaceReconstructionThreshold"})}),"\n",(0,i.jsxs)(n.p,{children:["Tama\xf1o de archivo m\xednimo (en bytes) necesarios para realizar una ",(0,i.jsx)(n.strong,{children:"reconstrucci\xf3n in-place"})," en lugar de usar un archivo temporal.\nPor defecto: ",(0,i.jsx)(n.code,{children:"400 * 1024 * 1024"})," (400 MB)."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Reconstrucci\xf3n in-place:"}),"\nEl archivo existente es abierto y actualizado directamente sobreescribiendo solo los chunks modificados o faltantes."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Reconstrucci\xf3n .tmp:"}),"\nEl archivo es completamente reconstruido en un ",(0,i.jsx)(n.code,{children:".tmp"})," temporal usando todos los chunks (nuevos y existentes), luego se reemplaza sobre el archivo original."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"C\xfaando usar:"})}),"\n",(0,i.jsxs)(n.p,{children:["La reconstrucci\xf3n in-place se recomienda para ",(0,i.jsx)(n.strong,{children:"archivos grandes"}),", ya que evita reescribir el archivo completo y reduce dr\xe1sticamente el uso del espacio en disco.\nSin embargo, puede ser ",(0,i.jsx)(n.strong,{children:"inseguro para ciertos formatos"})," (ejemplo: Archivos zip o bases de datos) que son sensibles a las escrituras parciales o la corrupci\xf3n.\nPara desactivar la reconstrucci\xf3n in-place por completo, pon este valor como ",(0,i.jsx)(n.code,{children:"0"}),"."]}),"\n",(0,i.jsx)(n.h4,{id:"fileconcurrency",children:(0,i.jsx)(n.code,{children:"fileConcurrency"})}),"\n",(0,i.jsxs)(n.p,{children:["Cu\xe1ntos archivos se reconstruir\xe1n concurrentemente (por defecto el valor es 5). (",(0,i.jsx)(n.code,{children:"number"}),")"]}),"\n",(0,i.jsx)(n.h4,{id:"onprogress",children:(0,i.jsx)(n.code,{children:"onProgress"})}),"\n",(0,i.jsx)(n.p,{children:"Callback que devuelve el uso del disco y una velocidad de red opcional (solo funciona con los chunk sources que usan el almacenamiento y la estrategia de streaming descarga-reconstrucci\xf3n)"})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>c,x:()=>a});var s=r(6540);const i={},o=s.createContext(i);function c(e){const n=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);