"use strict";(globalThis.webpackChunkrac_delta_docs=globalThis.webpackChunkrac_delta_docs||[]).push([[9136],{1470:(e,n,a)=>{a.d(n,{A:()=>_});var r=a(6540),s=a(4164),o=a(7559),i=a(3104),t=a(6347),c=a(205),d=a(7485),l=a(1682),u=a(679);function h(e){return r.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}function p(e){const{values:n,children:a}=e;return(0,r.useMemo)(()=>{const e=n??function(e){return h(e).map(({props:{value:e,label:n,attributes:a,default:r}})=>({value:e,label:n,attributes:a,default:r}))}(a);return function(e){const n=(0,l.XI)(e,(e,n)=>e.value===n.value);if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map(e=>e.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e},[n,a])}function x({value:e,tabValues:n}){return n.some(n=>n.value===e)}function m({queryString:e=!1,groupId:n}){const a=(0,t.W6)(),s=function({queryString:e=!1,groupId:n}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,d.aZ)(s),(0,r.useCallback)(e=>{if(!s)return;const n=new URLSearchParams(a.location.search);n.set(s,e),a.replace({...a.location,search:n.toString()})},[s,a])]}function g(e){const{defaultValue:n,queryString:a=!1,groupId:s}=e,o=p(e),[i,t]=(0,r.useState)(()=>function({defaultValue:e,tabValues:n}){if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!x({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map(e=>e.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const a=n.find(e=>e.default)??n[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:n,tabValues:o})),[d,l]=m({queryString:a,groupId:s}),[h,g]=function({groupId:e}){const n=function(e){return e?`docusaurus.tab.${e}`:null}(e),[a,s]=(0,u.Dv)(n);return[a,(0,r.useCallback)(e=>{n&&s.set(e)},[n,s])]}({groupId:s}),j=(()=>{const e=d??h;return x({value:e,tabValues:o})?e:null})();(0,c.A)(()=>{j&&t(j)},[j]);return{selectedValue:i,selectValue:(0,r.useCallback)(e=>{if(!x({value:e,tabValues:o}))throw new Error(`Can't select invalid tab value=${e}`);t(e),l(e),g(e)},[l,g,o]),tabValues:o}}var j=a(2303);const b={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var f=a(4848);function v({className:e,block:n,selectedValue:a,selectValue:r,tabValues:o}){const t=[],{blockElementScrollPositionUntilNextRender:c}=(0,i.a_)(),d=e=>{const n=e.currentTarget,s=t.indexOf(n),i=o[s].value;i!==a&&(c(n),r(i))},l=e=>{let n=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const a=t.indexOf(e.currentTarget)+1;n=t[a]??t[0];break}case"ArrowLeft":{const a=t.indexOf(e.currentTarget)-1;n=t[a]??t[t.length-1];break}}n?.focus()};return(0,f.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.A)("tabs",{"tabs--block":n},e),children:o.map(({value:e,label:n,attributes:r})=>(0,f.jsx)("li",{role:"tab",tabIndex:a===e?0:-1,"aria-selected":a===e,ref:e=>{t.push(e)},onKeyDown:l,onClick:d,...r,className:(0,s.A)("tabs__item",b.tabItem,r?.className,{"tabs__item--active":a===e}),children:n??e},e))})}function y({lazy:e,children:n,selectedValue:a}){const o=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const e=o.find(e=>e.props.value===a);return e?(0,r.cloneElement)(e,{className:(0,s.A)("margin-top--md",e.props.className)}):null}return(0,f.jsx)("div",{className:"margin-top--md",children:o.map((e,n)=>(0,r.cloneElement)(e,{key:n,hidden:e.props.value!==a}))})}function w(e){const n=g(e);return(0,f.jsxs)("div",{className:(0,s.A)(o.G.tabs.container,"tabs-container",b.tabList),children:[(0,f.jsx)(v,{...n,...e}),(0,f.jsx)(y,{...n,...e})]})}function _(e){const n=(0,j.A)();return(0,f.jsx)(w,{...e,children:h(e.children)},String(n))}},4637:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>u,contentTitle:()=>l,default:()=>x,frontMatter:()=>d,metadata:()=>r,toc:()=>h});const r=JSON.parse('{"id":"usage/downloading","title":"Descargas","description":"Una de las operaciones principales de rac-delta es la descarga de nuevas actualizaciones de tus builds o directorios, descargar nuevos chunks y reconstruir archivos.","source":"@site/i18n/es/docusaurus-plugin-content-docs/current/usage/downloading.mdx","sourceDirName":"usage","slug":"/usage/downloading","permalink":"/rac-delta-docs/es/usage/downloading","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Subidas","permalink":"/rac-delta-docs/es/usage/uploading"},"next":{"title":"Servicios","permalink":"/rac-delta-docs/es/usage/services"}}');var s=a(4848),o=a(8453),i=a(1470),t=a(9365),c=a(3457);const d={sidebar_position:3},l="Descargas",u={},h=[{value:"Pipeline de descarga",id:"pipeline-de-descarga",level:2},{value:"Estrategias de actualizaci\xf3n",id:"estrategias-de-actualizaci\xf3n",level:2},{value:"Descargar primero todo a disco",id:"descargar-primero-todo-a-disco",level:3},{value:"Descargar primero todo a memoria",id:"descargar-primero-todo-a-memoria",level:3},{value:"Stream desde red",id:"stream-desde-red",level:3},{value:"C\xf3mo funciona la reconstrucci\xf3n",id:"c\xf3mo-funciona-la-reconstrucci\xf3n",level:2},{value:"M\xe9todos auxiliares de pipelines",id:"m\xe9todos-auxiliares-de-pipelines",level:2}];function p(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"descargas",children:"Descargas"})}),"\n",(0,s.jsx)(n.p,{children:"Una de las operaciones principales de rac-delta es la descarga de nuevas actualizaciones de tus builds o directorios, descargar nuevos chunks y reconstruir archivos."}),"\n",(0,s.jsx)(n.p,{children:"Puedes usar rac-delta SDK para descargar una build por completo o solo los cambios."}),"\n",(0,s.jsx)(n.h2,{id:"pipeline-de-descarga",children:"Pipeline de descarga"}),"\n",(0,s.jsx)(n.p,{children:"Para esto, rac-delta SDK dispone de una pipeline de descarga que ya implementa todos los pasos para descargar builds autom\xe1ticamente."}),"\n",(0,s.jsxs)(i.A,{children:[(0,s.jsxs)(t.A,{value:"node",label:"Node.js",children:[(0,s.jsx)("h4",{children:"Uso b\xe1sico de la pipeline:"}),(0,s.jsx)(c.A,{className:"language-ts",children:"\n  const remoteIndexToUse = undefined;\n\n  await racDeltaClient.pipelines.download.execute(\n      /my/path/dir,\n      UpdateStrategy.DownloadAllFirstToDisk,\n      remoteIndexToUse,\n      {\n          chunksSavePath: 'tmp',\n          useExistingIndex: false,\n          force: false,\n          fileReconstructionConcurrency: 4,\n          inPlaceReconstructionThreshold: 400 * 1024 * 1024,\n          onStateChange: (state) => {\n              console.log(state);\n          },\n          onProgress: (type, progress, diskUsage, speed) => {\n              // imprimir y formatear progreso\n          }\n      }\n  );\n\n"}),(0,s.jsx)("h4",{children:"Parameters:"}),(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"ruta"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"string"})}),(0,s.jsx)(n.td,{children:"La ruta a tu build local que ser\xe1 actualizada (ruta relativa o absoluta)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"updateStrategy"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"UpdateStrategy"})}),(0,s.jsx)(n.td,{children:'La estrategia que ser\xe1 usada para descargar y reconstruir los archivos locales. Visita "Estrategias de actualizaci\xf3n" abajo para m\xe1s info.'})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"rd-index remoto"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"RDIndex"})}),(0,s.jsx)(n.td,{children:"El rd-index.json como objeto RDIndex que ser\xe1 usado como \xedndice remoto, si no se proporciona ninguno, la pipeline tratar\xe1 de descargarlo de tu almacenamiento."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"opciones de descarga"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"DownloadOptions"})}),(0,s.jsx)(n.td,{children:(0,s.jsxs)("table",{children:[" ",(0,s.jsxs)("thead",{children:[" ",(0,s.jsxs)("tr",{children:[" ",(0,s.jsx)("th",{children:"Par\xe1metro"})," ",(0,s.jsx)("th",{children:"Tipo"})," ",(0,s.jsx)("th",{children:"Descripci\xf3n"})," "]})," "]})," ",(0,s.jsxs)("tbody",{children:[" ",(0,s.jsxs)("tr",{children:[" ",(0,s.jsx)("td",{children:"chunksSavePath"})," ",(0,s.jsx)("td",{children:(0,s.jsx)("code",{children:"string"})})," ",(0,s.jsx)("td",{children:'La ruta donde los chunks ser\xe1n descargados y guardados temporalmente si eliges la estrategia de reconstrucci\xf3n de "descargar primero en disco"'})," "]})," ",(0,s.jsxs)("tr",{children:[" ",(0,s.jsx)("td",{children:"useExistingIndex"}),(0,s.jsx)("td",{children:(0,s.jsx)("code",{children:"boolean"})}),(0,s.jsx)("td",{children:"Si es true intentar\xe1 buscar el \xedndice en la ruta dada, para usarlo como rd-index local"})," "]})," ",(0,s.jsxs)("tr",{children:[" ",(0,s.jsx)("td",{children:"force"})," ",(0,s.jsx)("td",{children:(0,s.jsx)("code",{children:"boolean"})})," ",(0,s.jsx)("td",{children:"Si true, descargar\xe1 todo"})," "]})," ",(0,s.jsxs)("tr",{children:[" ",(0,s.jsx)("td",{children:"fileReconstructionConcurrency"})," ",(0,s.jsx)("td",{children:(0,s.jsx)("code",{children:"number"})})," ",(0,s.jsx)("td",{children:"L\xedmite de concurrencia para el proceso de reconstrucci\xf3n, usar\xe1 el maxConcurrency del cliente si no se proporciona ninguno."})," "]})," ",(0,s.jsxs)("tr",{children:[(0,s.jsx)("td",{children:"inPlaceReconstructionThreshold"})," ",(0,s.jsx)("td",{children:(0,s.jsx)("code",{children:"number"})})," ",(0,s.jsx)("td",{children:"El tama\xf1o l\xedmite de archivo (en bytes) para usar la reconstrucci\xf3n in-place en lugar de la reconstrucci\xf3n en .tmp. El valor por defecto es de 400MB. La reconstrucci\xf3n in-place se recomienda para archivos grandes, pero puede dar lugar a corrupciones de archivo, si no quieres ninguna reconstrucci\xf3n in-place, simplemente deja este valor como 0"})," "]})," ",(0,s.jsxs)("tr",{children:[" ",(0,s.jsx)("td",{children:"onStateChange"}),(0,s.jsx)("td",{children:(0,s.jsx)("code",{children:"(state: DownloadState) => void"})})," ",(0,s.jsxs)("td",{children:["Callback que notificar\xe1 cuando una pipeline cambie su estado. Los estados disponibles son: ",(0,s.jsx)(n.strong,{children:"downloading"}),", ",(0,s.jsx)(n.strong,{children:"reconstructing"}),", ",(0,s.jsx)(n.strong,{children:"cleaning"})," y ",(0,s.jsx)(n.strong,{children:"scanning"})]})," "]})," ",(0,s.jsxs)("tr",{children:[(0,s.jsx)("td",{children:"onProgress"}),(0,s.jsx)("td",{children:(0,s.jsx)("code",{children:'(type: "deleting" | "download" | "reconstructing", progress: number, diskUsage?: number, speed?: number) => void'})}),(0,s.jsx)("td",{children:"Callback que norificar\xe1 el progreso de las operaciones de descarga. Notificar\xe1 el progreso de descarga y la velocidad de red, el progreso de reconstrucci\xf3n y la velocidad del disco, y el progreso de eliminaci\xf3n de chunks remotos."})]})," "]})," "]})})]})]})]})]}),(0,s.jsxs)(t.A,{value:"rust",label:"Rust",children:[(0,s.jsx)("h4",{children:"Uso b\xe1sico de la pipeline:"}),(0,s.jsx)(c.A,{className:"language-rust",children:'\n  let remote_index_to_use: Option<RDIndex> = None;\n\n  match client.pipelines.download {\n      DownloadPipelineBundle::Hash(pipeline) => {\n          pipeline\n              .execute(\n                  Path::new("my/dir"),\n                  UpdateStrategy::DownloadAllFirstToDisk,\n                  remote_index_to_use,\n                  Some(DownloadOptions {\n                      chunks_save_path: Some(Path::new("dir/.tmp").to_path_buf()),\n                      use_existing_index: Some(false),\n                      force: Some(false),\n                      file_reconstruction_concurrency: Some(4),\n                      in_place_reconstruction_threshold: Some(400 * 1024 * 1024),\n                      on_state_change: Some(std::sync::Arc::new(|state| {\n                          println!("Download state: {:?}", state);\n                      })),\n                      on_progress: Some(std::sync::Arc::new(\n                          |progress_type, progress, disk_usage, speed| {\n                              // Imprimir y formatear progreso\n                          },\n                      )),\n                  }),\n              )\n              .await?;\n      }\n      DownloadPipelineBundle::Url(_p) => {\n          // nada para SSH\n      }\n  }\n  '}),(0,s.jsx)("h4",{children:"Par\xe1metros:"}),(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Nombre"}),(0,s.jsx)(n.th,{children:"Tipo"}),(0,s.jsx)(n.th,{children:"Descripci\xf3n"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"ruta"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Path"})}),(0,s.jsx)(n.td,{children:"La ruta a tu build local que ser\xe1 actualizada (ruta relativa o absoluta)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"updateStrategy"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"UpdateStrategy"})}),(0,s.jsx)(n.td,{children:'La estrategia que ser\xe1 usada para descargar y reconstruir los archivos locales. Visita "Estrategias de actualizaci\xf3n" abajo para m\xe1s info.'})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"rd-index remoto"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"RDIndex"})}),(0,s.jsx)(n.td,{children:"El rd-index.json como objeto RDIndex que ser\xe1 usado como \xedndice remoto, si no se proporciona ninguno, la pipeline tratar\xe1 de descargarlo de tu almacenamiento."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"opciones de descarga"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"DownloadOptions"})}),(0,s.jsx)(n.td,{children:(0,s.jsxs)("table",{children:[" ",(0,s.jsxs)("thead",{children:[" ",(0,s.jsxs)("tr",{children:[" ",(0,s.jsx)("th",{children:"Par\xe1metro"})," ",(0,s.jsx)("th",{children:"Tipo"})," ",(0,s.jsx)("th",{children:"Descripci\xf3n"})," "]})," "]})," ",(0,s.jsxs)("tbody",{children:[" ",(0,s.jsxs)("tr",{children:[" ",(0,s.jsx)("td",{children:"chunks_save_path"})," ",(0,s.jsx)("td",{children:(0,s.jsx)("code",{children:"Option<PathBuf>"})})," ",(0,s.jsx)("td",{children:'La ruta donde los chunks ser\xe1n descargados y guardados temporalmente si eliges la estrategia de reconstrucci\xf3n de "descargar primero en disco"'})," "]})," ",(0,s.jsxs)("tr",{children:[" ",(0,s.jsx)("td",{children:"use_existing_index"}),(0,s.jsx)("td",{children:(0,s.jsx)("code",{children:"Option<bool>"})}),(0,s.jsx)("td",{children:"Si es true intentar\xe1 buscar el \xedndice en la ruta dada, para usarlo como rd-index local"})," "]})," ",(0,s.jsxs)("tr",{children:[" ",(0,s.jsx)("td",{children:"force"})," ",(0,s.jsx)("td",{children:(0,s.jsx)("code",{children:"Option<bool>"})})," ",(0,s.jsx)("td",{children:"Si es true, descargar\xe1 todo."})," "]})," ",(0,s.jsxs)("tr",{children:[" ",(0,s.jsx)("td",{children:"file_reconstruction_concurrency"})," ",(0,s.jsx)("td",{children:(0,s.jsx)("code",{children:"Option<usize>"})})," ",(0,s.jsx)("td",{children:"L\xedmite de concurrencia para el proceso de reconstrucci\xf3n, usar\xe1 el maxConcurrency del cliente si no se proporciona ninguno."})," "]})," ",(0,s.jsxs)("tr",{children:[(0,s.jsx)("td",{children:"in_place_reconstruction_threshold"})," ",(0,s.jsx)("td",{children:(0,s.jsx)("code",{children:"Option<u64>"})})," ",(0,s.jsx)("td",{children:"El tama\xf1o l\xedmite de archivo (en bytes) para usar la reconstrucci\xf3n in-place en lugar de la reconstrucci\xf3n en .tmp. El valor por defecto es de 400MB. La reconstrucci\xf3n in-place se recomienda para archivos grandes, pero puede dar lugar a corrupciones de archivo, si no quieres ninguna reconstrucci\xf3n in-place, simplemente marca este valor como 0"})," "]})," ",(0,s.jsxs)("tr",{children:[" ",(0,s.jsx)("td",{children:"on_state_change"}),(0,s.jsx)("td",{children:(0,s.jsx)("code",{children:"Option<Arc<dyn Fn(DownloadState) + Send + Sync + 'static, Global>>"})})," ",(0,s.jsxs)("td",{children:["Callback que notificar\xe1 cuando una pipeline cambie su estado. Los estados disponibles son: ",(0,s.jsx)(n.strong,{children:"downloading"}),", ",(0,s.jsx)(n.strong,{children:"reconstructing"}),", ",(0,s.jsx)(n.strong,{children:"cleaning"})," y ",(0,s.jsx)(n.strong,{children:"scanning"})]})," "]})," ",(0,s.jsxs)("tr",{children:[(0,s.jsx)("td",{children:"on_progress"}),(0,s.jsx)("td",{children:(0,s.jsx)("code",{children:"Option<Arc<dyn Fn(DownloadPhase, f64, Option<f64>, Option<f64>) + Send + Sync + 'static, Global>>"})}),(0,s.jsx)("td",{children:"Callback que norificar\xe1 el progreso de las operaciones de descarga. Notificar\xe1 el progreso de descarga y la velocidad de red, el progreso de reconstrucci\xf3n y la velocidad del disco, y el progreso de eliminaci\xf3n de chunks remotos."})]})," "]})," "]})})]})]})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"Esto autom\xe1ticamente generar\xe1 o usar\xe1 un rd-index local existente, descargar\xe1 el rd-index remoto si no se proporciona ninguno, y descargar\xe1 y reconstruir\xe1 los archivos de la actualizaci\xf3n desde tu almacenamiento configurado."}),"\n",(0,s.jsx)(n.h2,{id:"estrategias-de-actualizaci\xf3n",children:"Estrategias de actualizaci\xf3n"}),"\n",(0,s.jsx)(n.p,{children:"La pipeline de descarga proporciona tres estrategias de actualizaci\xf3n diferentes que afectar\xe1n a c\xf3mo los chunks se almacenan y c\xf3mo los archivos ser\xe1n reconstruidos."}),"\n",(0,s.jsx)(n.h3,{id:"descargar-primero-todo-a-disco",children:"Descargar primero todo a disco"}),"\n",(0,s.jsxs)(n.p,{children:["Usar ",(0,s.jsx)(n.code,{children:"UpdateStrategy.DownloadAllFirstToDisk"})," har\xe1 exactamente lo que dice, descargar\xe1 todos los chunks a un directorio temporal en tu disco, y entonces reconstruir\xe1 los archivos desde ah\xed, haci\xe9ndolo una buena opci\xf3n para usuarios con conexi\xf3n lenta pero disco r\xe1pido."]}),"\n",(0,s.jsx)(n.admonition,{title:"Nota",type:"tip",children:(0,s.jsxs)(n.p,{children:["Al usar esta estrategia, debes proporcionar una ruta de guardado de chunks en ",(0,s.jsx)(n.code,{children:"DownloadOptions"})]})}),"\n",(0,s.jsx)(n.h3,{id:"descargar-primero-todo-a-memoria",children:"Descargar primero todo a memoria"}),"\n",(0,s.jsxs)(n.p,{children:["Similar a disco, usar ",(0,s.jsx)(n.code,{children:"UpdateStrategy.DownloadAllFirstToMemory"})," descargar\xe1 todos los chunks primero a memoria, y entonces reconstruir\xe1 los archivos desde ah\xed. Esta es la opci\xf3n m\xe1s r\xe1pida, ya que reconstruir\xe1 directamente nada m\xe1s descargar sin pasos extra, pero solo se recomienda para descargas peque\xf1as."]}),"\n",(0,s.jsx)(n.h3,{id:"stream-desde-red",children:"Stream desde red"}),"\n",(0,s.jsxs)(n.p,{children:["Esta estrategia ",(0,s.jsx)(n.code,{children:"UpdateStrategy.StreamFromNetwork"})," har\xe1 streaming de los chunks desde tu almacenamiento y reconstruir\xe1 los archivos de forma concurrente, esta estrategia apenas usa memoria y es perfecta para m\xe1quinas con poca memoria y conexi\xf3n r\xe1pida. Esta es la estrategia recomendada."]}),"\n",(0,s.jsx)(n.h2,{id:"c\xf3mo-funciona-la-reconstrucci\xf3n",children:"C\xf3mo funciona la reconstrucci\xf3n"}),"\n",(0,s.jsxs)(n.p,{children:["Para la reconstrucci\xf3n de archivos, rac-delta usar\xe1 los chunks existentes + nuevos chunks para reconstruir. Reconstruir\xe1 el archivo en una ruta ",(0,s.jsx)(n.code,{children:"archivo.tmp"})," y una vez haya terminado, sobreescribir\xe1 el archivo original."]}),"\n",(0,s.jsxs)(n.p,{children:["Si ",(0,s.jsx)(n.code,{children:"inPlaceReconstructionThreshold"})," est\xe1 configurado, reconstruir\xe1 in-place en lugar de .tmp para el tama\xf1o especificado, se recomienda usar reconstrucci\xf3n in-place para archivos grandes, ya que el .tmp requiere algo de espacio extra en disco, pero usar in-place podr\xeda llevar a la corrupci\xf3n de algunos tipos de archivo, como .zip o v\xeddeo."]}),"\n",(0,s.jsxs)(n.p,{children:["Para m\xe1s informaci\xf3n, echa un ojo a ",(0,s.jsx)(n.a,{href:"/core/services#reconstruction-service",children:"servicio de reconstrucci\xf3n"})]}),"\n",(0,s.jsx)(n.h2,{id:"m\xe9todos-auxiliares-de-pipelines",children:"M\xe9todos auxiliares de pipelines"}),"\n",(0,s.jsx)(n.p,{children:"Para conseguir un parcheo y descarga correctos de un directorio usando rac-delta, la pipeline de descarga usa m\xe9todos internos que usan los servicios de rac-delta para descargar, comparar \xedndices, reconstruir, etc..."}),"\n",(0,s.jsxs)(n.p,{children:["Si no quieres usar el m\xe9todo ",(0,s.jsx)(n.code,{children:"execute"})," por defecto, puedes crear tu propia pipeline usando estos m\xe9todos auxiliares y los servicios."]}),"\n",(0,s.jsxs)(i.A,{children:[(0,s.jsxs)(t.A,{value:"node",label:"Node.js",children:[(0,s.jsx)("h4",{children:"Ejemplo de uso de los m\xe9todos auxiliares:"}),(0,s.jsx)(c.A,{className:"language-ts",children:"\n  const racDeltaClient = new RacDeltaClient({\n  chunkSize: 1024 * 1024,\n  maxConcurrency: 6,\n  storage: {\n      type: 'ssh',\n      host: 'localhost',\n      pathPrefix: '/root/upload',\n      port: 2222,\n      credentials: {\n      username: 'root',\n      password: 'password',\n      },\n  },\n  });\n\n  // Descarga el \xedndice remoto desde tu fuente\n  const remoteIndex = fetch('my/api/or/my/storage/rd-index.json');\n\n  // Generamos un \xedndice local (puedes buscar uno existente usando .findLocalIndex)\n  const localIndex = await racDeltaClient.pipelines.download.loadLocalIndex('my/build');\n\n  // Generamos el plan delta para la descarga\n  const deltaPlan = await racDeltaClient.delta.compareForDownload(localIndex, remoteIndex);\n\n  // Usamos la estrategia de descargar a disco. Los chunk sources son mini servicios que conectan el servicio de reconstrucci\xf3n con una fuente de chunks\n  // (en este caso, tu propio disco)\n  const diskChunkSource = await racDeltaClient.pipelines.download.downloadAllMissingChunks(\n  deltaPlan,\n  'disk',\n  {\n    chunksSavePath: 'my/temp',\n  }\n  );\n\n  // Entonces reconstruimos todos los archivos de la actualizaci\xf3n y guardamos el \xedndice\n  await racDeltaClient.reconstruction.reconstructAll(deltaPlan, 'my/build', diskChunkSource);\n\n  await racDeltaClient.pipelines.download.saveLocalIndex('my/build', remoteIndex);\n\n"})]}),(0,s.jsxs)(t.A,{value:"rust",label:"Rust",children:[(0,s.jsx)("h4",{children:"Ejemplo de uso de los m\xe9todos auxiliares:"}),(0,s.jsx)(c.A,{className:"language-rust",children:'\n  let config = RacDeltaConfig {\n      chunk_size: 1024 * 1024,\n      max_concurrency: Some(6),\n      storage: StorageConfig::SSH(SSHStorageConfig {\n          base: BaseStorageConfig {\n              path_prefix: Some("/root/upload".to_string()),\n          },\n          host: "localhost".to_string(),\n          port: Some(2222),\n          credentials: SSHCredentials {\n              username: "root".to_string(),\n              password: Some("password".to_string()),\n              private_key: None,\n          },\n      }),\n  };\n\n  let client: RacDeltaClient = RacDeltaClient::new(config).await?;\n\n  let remote_index = fetch from remote...;\n\n  // Generamos el rd-index.json local (podr\xedas usar client.delta.create_index_from_directory tambi\xe9n)\n  let local_index: Option<RDIndex> = match client.pipelines.download {\n      DownloadPipelineBundle::Hash(ref pipeline) => {\n          Some(pipeline.load_local_index(Path::new("my/dir")).await?)\n      }\n      DownloadPipelineBundle::Url(ref _p) => None,\n  };\n\n  // Generamos un DeltaPlan comparando ambos \xedndices\n  let delta_plan: DeltaPlan = client\n      .delta\n      .compare_for_download(Some(&local_index.unwrap()), remote_index)\n      .await?;\n\n  // Usamos la estrategia de descargar a disco. Los chunk sources son mini servicios que conectan el servicio de reconstrucci\xf3n con una fuente de chunks\n  // (en este caso, tu propio disco)\n  let chunk_source: Option<Arc<dyn ChunkSource>> = match client.pipelines.download {\n      DownloadPipelineBundle::Hash(ref pipeline) => Some(\n          pipeline\n              .download_all_missing_chunks(\n                  &delta_plan,\n                  DownloadTarget::Disk,\n                  Some(DownloadOptions {\n                      chunks_save_path: Some(Path::new("my/temp").to_path_buf()),\n                      ..Default::default()\n                  }),\n              )\n              .await?,\n      ),\n      DownloadPipelineBundle::Url(ref _p) => None,\n  };\n\n  client.reconstruction.reconstruct_all(\n      &delta_plan,\n      Path::new("my/dir"),\n      chunk_source.unwrap(),\n      None,\n  );\n\n  match client.pipelines.download {\n      DownloadPipelineBundle::Hash(ref pipeline) => {\n          pipeline\n              .save_local_index(Path::new("my/dir"), &local_index.unwrap())\n              .await?\n      }\n\n      DownloadPipelineBundle::Url(ref _p) => (),\n  };\n  '}),(0,s.jsx)(n.p,{children:"En Rust, las pipelines siempre est\xe1n divididas en Hash y Url, esto es as\xed porque UrlPipeline execute difiere de HashPipeline, haciendo un Enum resuelve esto parcialmente, \xa1pero el proyecto est\xe1 abierto a mejoras!"}),(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Nota"}),": Para casi todos los casos usar\xe1s la pipeline Hash, Url es solo para el tipo de almacenamiento URL."]})]})]}),"\n",(0,s.jsxs)(n.p,{children:["Para una lista completa de los m\xe9todos auxiliares echa un ojo a: ",(0,s.jsx)(n.a,{href:"/core/pipelines",children:"pipelines"}),"\nTambi\xe9n a ",(0,s.jsx)(n.a,{href:"/core/interfaces#DeltaPlan",children:"DeltaPlan"})]})]})}function x(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}},9365:(e,n,a)=>{a.d(n,{A:()=>i});a(6540);var r=a(4164);const s={tabItem:"tabItem_Ymn6"};var o=a(4848);function i({children:e,hidden:n,className:a}){return(0,o.jsx)("div",{role:"tabpanel",className:(0,r.A)(s.tabItem,a),hidden:n,children:e})}}}]);