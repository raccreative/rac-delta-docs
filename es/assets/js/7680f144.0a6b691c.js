"use strict";(globalThis.webpackChunkrac_delta_docs=globalThis.webpackChunkrac_delta_docs||[]).push([[5267],{7107:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>t,contentTitle:()=>i,default:()=>u,frontMatter:()=>d,metadata:()=>c,toc:()=>l});const c=JSON.parse('{"id":"reference/Rust/services/reconstruction-service","title":"ReconstructionService","description":"Servicio encargado de reconstruir archivos desde chunks usando cualquier ChunkSource.","source":"@site/i18n/es/docusaurus-plugin-content-docs/current/reference/Rust/services/reconstruction-service.md","sourceDirName":"reference/Rust/services","slug":"/reference/Rust/services/reconstruction-service","permalink":"/rac-delta-docs/es/reference/Rust/services/reconstruction-service","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"title":"ReconstructionService","description":"Servicio encargado de reconstruir archivos desde chunks usando cualquier ChunkSource.","sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"DeltaService","permalink":"/rac-delta-docs/es/reference/Rust/services/delta-service"},"next":{"title":"Chunk Sources","permalink":"/rac-delta-docs/es/category/chunk-sources-1"}}');var s=n(4848),o=n(8453);const d={title:"ReconstructionService",description:"Servicio encargado de reconstruir archivos desde chunks usando cualquier ChunkSource.",sidebar_position:4},i="ReconstructionService",t={},l=[{value:"M\xe9todos",id:"m\xe9todos",level:2},{value:"ReconstructionError",id:"reconstructionerror",level:2},{value:"ReconstructionOptions",id:"reconstructionoptions",level:2},{value:"Detalles de m\xe9todos",id:"detalles-de-m\xe9todos",level:2},{value:"<code>reconstruct_file(entry, output_path, chunk_source, options, cb)</code>",id:"reconstruct_fileentry-output_path-chunk_source-options-cb",level:3},{value:"<code>reconstruct_all(plan, output_dir, chunk_source, options)</code>",id:"reconstruct_allplan-output_dir-chunk_source-options",level:3},{value:"<code>reconstruct_to_stream(entry, chunk_source)</code>",id:"reconstruct_to_streamentry-chunk_source",level:3},{value:"Relacionado",id:"relacionado",level:2}];function h(e){const r={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.header,{children:(0,s.jsx)(r.h1,{id:"reconstructionservice",children:"ReconstructionService"})}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.code,{children:"ReconstructionService"})," define la interfaz principal responsable de ",(0,s.jsx)(r.strong,{children:"reconstruir archivos desde sus chunks"}),", ya sea a disco o stream.\nEste servicio se comunica directamente con un ",(0,s.jsx)(r.a,{href:"../chunk-sources/chunk-source",children:(0,s.jsx)(r.code,{children:"ChunkSource"})})," para obtener los datos necesarios y reconstruir el archivo."]}),"\n",(0,s.jsx)(r.p,{children:"Sirve como el componente principal del proceso de restauraci\xf3n en rac-delta."}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsx)(r.h2,{id:"m\xe9todos",children:"M\xe9todos"}),"\n",(0,s.jsxs)(r.table,{children:[(0,s.jsx)(r.thead,{children:(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.th,{children:"M\xe9todo"}),(0,s.jsx)(r.th,{children:"Devuelve"}),(0,s.jsx)(r.th,{children:"Descripci\xf3n"})]})}),(0,s.jsxs)(r.tbody,{children:[(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"reconstruct_file(entry, output_path, chunk_source, options, cb)"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"Result<(), ReconstructionError>"})}),(0,s.jsx)(r.td,{children:"Reconstruye un \xfanico archivo en disco."})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"reconstruct_all(plan, output_dir, chunk_source, options)"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"Result<(), ReconstructionError>"})}),(0,s.jsx)(r.td,{children:"Reconstruye todos los archivos de un DeltaPlan en disco."})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"reconstruct_to_stream(entry, chunk_source)"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"Result<Pin<Box<dyn AsyncRead + Send + Sync>>, ReconstructionError>"})}),(0,s.jsx)(r.td,{children:"Reconstruye un archivo en memoria y lo devuelve como stream."})]})]})]}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsx)(r.h2,{id:"reconstructionerror",children:"ReconstructionError"}),"\n",(0,s.jsxs)(r.p,{children:["Enum de errores personalizado para los resultados de ReconstructionService. (Usa ",(0,s.jsx)(r.code,{children:"thiserror"}),")"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-rust",children:'pub enum ReconstructionError {\n    #[error("I/O error: {0}")]\n    Io(#[from] std::io::Error),\n\n    #[error("Chunk \'{0}\' not found")]\n    ChunkNotFound(String),\n\n    #[error("Hash mismatch for file \'{0}\'")]\n    HashMismatch(String),\n\n    #[error("Failed to read chunk \'{0}\'")]\n    ChunkReadError(String),\n\n    #[error("Reconstruction failed: {0}")]\n    Other(String),\n}\n'})}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsx)(r.h2,{id:"reconstructionoptions",children:"ReconstructionOptions"}),"\n",(0,s.jsx)(r.p,{children:"Opciones para el proceso de reconstrucci\xf3n:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-rust",children:"pub struct ReconstructionOptions {\n    pub force_rebuild: Option<bool>,\n    pub verify_after_rebuild: Option<bool>,\n    pub in_place_reconstruction_threshold: Option<u64>,\n    pub file_concurrency: Option<usize>,\n    pub on_progress: Option<Arc<dyn Fn(f64, usize, Option<f64>, Option<usize>) + Send + Sync>>,\n}\n"})}),"\n",(0,s.jsxs)(r.table,{children:[(0,s.jsx)(r.thead,{children:(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.th,{children:"Par\xe1metro"}),(0,s.jsx)(r.th,{children:"Tipo"}),(0,s.jsx)(r.th,{children:"Descripci\xf3n"})]})}),(0,s.jsxs)(r.tbody,{children:[(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"force_rebuild"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"Option<bool>"})}),(0,s.jsx)(r.td,{children:"Forzar la reconstrucci\xf3n incluso si el hash del archivo coincide."})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"verify_after_rebuild"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"Option<bool>"})}),(0,s.jsx)(r.td,{children:"Verifica el hash del archivo reconstruido tras terminar. Si el hash no coincide, se lanza un error."})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"in_place_reconstruction_threshold"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"Option<u64>"})}),(0,s.jsxs)(r.td,{children:["Tama\xf1o de archivo m\xednimo (en bytes) necesarios para realizar una ",(0,s.jsx)(r.strong,{children:"reconstrucci\xf3n in-place"})," en lugar de usar un archivo temporal."]})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"file_concurrency"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"Option<usize>"})}),(0,s.jsx)(r.td,{children:"Cu\xe1ntos archivos se reconstruir\xe1n de forma concurrente (valor por defecto es 5)."})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"on_progress"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"Option<Arc<dyn Fn(f64, usize, Option<f64>, Option<usize>) + Send + Sync>>"})}),(0,s.jsx)(r.td,{children:"Callback que devuelve el uso de disco y la velocidad de red opcional (solo para chunk sources de almacenamiento v\xeda streaming descarga-reconstrucci\xf3n)"})]})]})]}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsx)(r.h2,{id:"detalles-de-m\xe9todos",children:"Detalles de m\xe9todos"}),"\n",(0,s.jsx)(r.h3,{id:"reconstruct_fileentry-output_path-chunk_source-options-cb",children:(0,s.jsx)(r.code,{children:"reconstruct_file(entry, output_path, chunk_source, options, cb)"})}),"\n",(0,s.jsxs)(r.p,{children:["Reconstruye un solo archivo desde un ",(0,s.jsx)(r.code,{children:"FileEntry"})," en disco."]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Par\xe1metros:"})}),"\n",(0,s.jsxs)(r.table,{children:[(0,s.jsx)(r.thead,{children:(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.th,{children:"Nombre"}),(0,s.jsx)(r.th,{children:"Tipo"}),(0,s.jsx)(r.th,{children:"Descripci\xf3n"})]})}),(0,s.jsxs)(r.tbody,{children:[(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"entry"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"&FileEntry"})}),(0,s.jsxs)(r.td,{children:["El ",(0,s.jsx)(r.code,{children:"FileEntry"})," que contiene la lista de chunks y la ruta del archivo."]})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"outputPath"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"&Path"})}),(0,s.jsx)(r.td,{children:"La ruta donde el archivo ser\xe1 reconstruido."})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"chunkSource"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"&dyn ChunkSource"})}),(0,s.jsx)(r.td,{children:"La implementaci\xf3n de chunk source desde donde se recolectar\xe1n los chunks."})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"options"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"Option<&ReconstructionOptions>"})}),(0,s.jsx)(r.td,{children:"Opciones para la reconstrucci\xf3n."})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"cb"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"Option<FileProgressCallback>"})}),(0,s.jsx)(r.td,{children:"Callback opcional para el progreso."})]})]})]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-rust",children:"pub type FileProgressCallback = Arc<dyn Fn(f64, usize, Option<usize>) + Send + Sync>;\n"})}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Devuelve:"})," ",(0,s.jsx)(r.code,{children:"Result<(), ReconstructionError"})]}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsx)(r.h3,{id:"reconstruct_allplan-output_dir-chunk_source-options",children:(0,s.jsx)(r.code,{children:"reconstruct_all(plan, output_dir, chunk_source, options)"})}),"\n",(0,s.jsx)(r.p,{children:"Reconstruye todos los archivos del DeltaPlan dado en disco."}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Par\xe1metros:"})}),"\n",(0,s.jsxs)(r.table,{children:[(0,s.jsx)(r.thead,{children:(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.th,{children:"Nombre"}),(0,s.jsx)(r.th,{children:"Tipo"}),(0,s.jsx)(r.th,{children:"Descripci\xf3n"})]})}),(0,s.jsxs)(r.tbody,{children:[(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"plan"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"&DeltaPlan"})}),(0,s.jsxs)(r.td,{children:["El ",(0,s.jsx)(r.code,{children:"DeltaPlan"})," que contiene los archivos a reconstruir."]})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"output_dir"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"&Path"})}),(0,s.jsx)(r.td,{children:"La ruta donde los archivos ser\xe1n reconstruidos."})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"chunk_source"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"Arc<dyn ChunkSource>"})}),(0,s.jsx)(r.td,{children:"La implementaci\xf3n de chunk source desde donde se recolectar\xe1n los chunks."})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"options"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"Option<&ReconstructionOptions>"})}),(0,s.jsx)(r.td,{children:"Opciones para la reconstrucci\xf3n."})]})]})]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Devuelve:"})," ",(0,s.jsx)(r.code,{children:"Result<(), ReconstructionError>"})]}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsx)(r.h3,{id:"reconstruct_to_streamentry-chunk_source",children:(0,s.jsx)(r.code,{children:"reconstruct_to_stream(entry, chunk_source)"})}),"\n",(0,s.jsx)(r.p,{children:"Reconstruye un archivo en memoria y lo devuelve como un stream."}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Par\xe1metros:"})}),"\n",(0,s.jsxs)(r.table,{children:[(0,s.jsx)(r.thead,{children:(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.th,{children:"Nombre"}),(0,s.jsx)(r.th,{children:"Tipo"}),(0,s.jsx)(r.th,{children:"Descripci\xf3n"})]})}),(0,s.jsxs)(r.tbody,{children:[(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"entry"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"FileEntry"})}),(0,s.jsxs)(r.td,{children:["El ",(0,s.jsx)(r.code,{children:"FileEntry"})," que contiene la lista de chunks y la ruta del archivo."]})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"chunk_source"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"Arc<dyn ChunkSource + Send + Sync>"})}),(0,s.jsx)(r.td,{children:"La implementaci\xf3n de chunk source desde donde se recolectar\xe1n los chunks."})]})]})]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Devuelve:"})," ",(0,s.jsx)(r.code,{children:"Result<Pin<Box<dyn AsyncRead + Send + Sync>>, ReconstructionError>"})]}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsx)(r.h2,{id:"relacionado",children:"Relacionado"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"/reference/Rust/models/delta-plan",children:"DeltaPlan"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"/reference/Rust/models/file-entry",children:"FileEntry"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"/reference/Rust/chunk-sources/chunk-source",children:"ChunkSource"})}),"\n"]})]})}function u(e={}){const{wrapper:r}={...(0,o.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>d,x:()=>i});var c=n(6540);const s={},o=c.createContext(s);function d(e){const r=c.useContext(o);return c.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function i(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:d(e.components),c.createElement(o.Provider,{value:r},e.children)}}}]);