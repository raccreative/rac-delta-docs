"use strict";(globalThis.webpackChunkrac_delta_docs=globalThis.webpackChunkrac_delta_docs||[]).push([[149],{7638:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>d,contentTitle:()=>i,default:()=>m,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"core/storage-adapter","title":"Adaptador de almacenamiento","description":"El adaptador de almacenamiento es un servicio especial que implementa el almacenamiento seleccionado usando la configuraci\xf3n vista en configuraci\xf3n. Como rac-delta es agn\xf3stico al almacenamiento, tener una abstracci\xf3n para este es una soluci\xf3n perfecta.","source":"@site/i18n/es/docusaurus-plugin-content-docs/current/core/storage-adapter.md","sourceDirName":"core","slug":"/core/storage-adapter","permalink":"/rac-delta-docs/es/core/storage-adapter","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Configuraci\xf3n","permalink":"/rac-delta-docs/es/core/configuration"},"next":{"title":"Servicios","permalink":"/rac-delta-docs/es/core/services"}}');var s=n(4848),r=n(8453);const o={sidebar_position:4},i="Adaptador de almacenamiento",d={},c=[{value:"Adaptador de almacenamiento base",id:"adaptador-de-almacenamiento-base",level:2},{value:"Adaptador de almacenamiento Hash",id:"adaptador-de-almacenamiento-hash",level:2},{value:"Adaptador de almacenamiento Url",id:"adaptador-de-almacenamiento-url",level:2}];function l(e){const a={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(a.header,{children:(0,s.jsx)(a.h1,{id:"adaptador-de-almacenamiento",children:"Adaptador de almacenamiento"})}),"\n",(0,s.jsxs)(a.p,{children:["El adaptador de almacenamiento es un servicio especial que implementa el almacenamiento seleccionado usando la configuraci\xf3n vista en ",(0,s.jsx)(a.a,{href:"/core/configuration",children:"configuraci\xf3n"}),". Como rac-delta es agn\xf3stico al almacenamiento, tener una abstracci\xf3n para este es una soluci\xf3n perfecta."]}),"\n",(0,s.jsx)(a.p,{children:"El adaptador de almacenamiento conectar\xe1 directamente con tu backend (Ejemplo: s3 sdk)."}),"\n",(0,s.jsx)(a.h2,{id:"adaptador-de-almacenamiento-base",children:"Adaptador de almacenamiento base"}),"\n",(0,s.jsx)(a.p,{children:"Como hay dos tipos de almacenamiento (Url o Hash), el adaptador necesita una clase base que ser\xe1 extendida. Esto se hace porque el adaptador URL necesita par\xe1metros y nombres diferentes."}),"\n",(0,s.jsx)(a.p,{children:"(Si planeas implementar solo un tipo de almacenamiento, entonces no necesitas usar esta divisi\xf3n de tipos y usar solo el que necesites)"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-ts",children:"abstract class StorageAdapter {\n  abstract readonly type: 'hash' | 'url';\n\n  abstract dispose(): Promise<void>;\n}\n"})}),"\n",(0,s.jsx)(a.h2,{id:"adaptador-de-almacenamiento-hash",children:"Adaptador de almacenamiento Hash"}),"\n",(0,s.jsx)(a.p,{children:"Este tipo de adaptador est\xe1 hecho para todos los almacenamientos que funcionan con rutas hash (por ejemplo: dir/chunks/hash). Todos los almacenamientos salvo URL usan este tipo."}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-ts",metastring:'title="Ejemplo de abstracci\xf3n en TypeScript"',children:"abstract class HashStorageAdapter extends StorageAdapter {\n  readonly type = 'hash' as const;\n\n  abstract getChunk(hash: string): Promise<Readable | null>;\n\n  abstract putChunk(\n    hash: string,\n    data: Readable,\n    opts?: { overwrite?: boolean; size?: number }\n  ): Promise<void>;\n\n  abstract chunkExists(hash: string): Promise<boolean>;\n\n  abstract deleteChunk(hash: string): Promise<void>;\n\n  listChunks?(): Promise<string[]>;\n\n  getChunkInfo?(hash: string): Promise<BlobInfo | null>;\n\n  abstract getRemoteIndex(): Promise<RDIndex | null>;\n\n  abstract putRemoteIndex(index: RDIndex): Promise<void>;\n}\n\n// usado por getChunkInfo\ninterface BlobInfo {\n  hash: string;\n  size: number;\n  modified?: Date;\n  metadata?: Record<string, string>;\n}\n"})}),"\n",(0,s.jsx)(a.h2,{id:"adaptador-de-almacenamiento-url",children:"Adaptador de almacenamiento Url"}),"\n",(0,s.jsx)(a.p,{children:"Este tipo de adaptador solo se usa par el tipo de almacenamiento URL:"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-ts",metastring:'title="Ejemplo de abstracci\xf3n en TypeScript"',children:"export abstract class UrlStorageAdapter extends StorageAdapter {\n  readonly type = 'url' as const;\n\n  abstract getChunkByUrl(url: string): Promise<Readable | null>;\n\n  abstract putChunkByUrl(url: string, data: Readable): Promise<void>;\n\n  abstract deleteChunkByUrl(url: string): Promise<void>;\n\n  abstract chunkExistsByUrl(url: string): Promise<boolean>;\n\n  listChunksByUrl?(url: string): Promise<string[]>;\n\n  getChunkInfoByUrl?(hash: string, url: string): Promise<BlobInfo | null>;\n\n  abstract getRemoteIndexByUrl(url: string): Promise<RDIndex | null>;\n\n  abstract putRemoteIndexByUrl(url: string, index: RDIndex): Promise<void>;\n}\n"})})]})}function m(e={}){const{wrapper:a}={...(0,r.R)(),...e.components};return a?(0,s.jsx)(a,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,a,n)=>{n.d(a,{R:()=>o,x:()=>i});var t=n(6540);const s={},r=t.createContext(s);function o(e){const a=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(a):{...a,...e}},[a,e])}function i(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(r.Provider,{value:a},e.children)}}}]);